//var expressMongoRest = require('express-mongo-rest')
var expressMongoRest = require('./external_libs/express-mongo-rest');
console.log(expressMongoRest);
var express = require('express');
var passport = require('passport');
var cors = require('cors');
var assert = require('assert'); 
var fs = require('fs');
var url = require('url');
const MongoClient = require('mongodb').MongoClient;
var query2m = require('query-to-mongo')

// config
var config = require('../config/default.json');
var serverConfig = config.PentestServer;
var clientConfig = config.PentestClient || {};
var credentials = require('../config/credentials.json').credentials;

// mongo
var mongourl = "mongodb://" + serverConfig.mongodb.port + "/" + serverConfig.mongodb.database;
if ('mongo_admin_password' in credentials) {
    mongourl = "mongodb://webapp:" + credentials.mongo_webapp_password + "@" + serverConfig.mongodb.host + ":" + serverConfig.mongodb.port + "/" + serverConfig.mongodb.database;
}
const client = new MongoClient(mongourl, {useUnifiedTopology: true});
var db = null;

client.connect(function (err){
    assert.equal(null, err);
    console.log("Connected successfully to MongoDB server");
    db = client.db(serverConfig.mongodb.database);
    // client.close();
    // db.listCollections().toArray(function(err, collInfos) {
    //     console.log('Collections in Mongo: ' + JSON.stringify(collInfos,null,4));
    // });
    // db.collection('pentests').find({}).toArray(function(err, collInfos) {
    //     console.log('Collections in Mongo: ' + JSON.stringify(collInfos,null,4));
    // });
});

// SAML setup ------------
var SamlStrategy = require('passport-saml').Strategy;

var findShortName = function(profile, cb) {
    id = profile[serverConfig.saml.uniqueUserIdAttributeName];
    if(id) {
        console.log("Login via SAML: " + JSON.stringify(profile));
        cb(null, {username: id, saml: profile, loginMethod: "saml"});
    } else {
        console.log("Login via SAML FAILED: id is undefined");
        return cb(Error("SAML login failed, username not found"));
    }
    // isAuthorized = serverConfig.authorizedUsers.indexOf(id) > -1;
    // if (isAuthorized) {
    //     console.log("Login successful: " + JSON.stringify(profile));
    //     cb(null, profile);
    // } else {
    //     console.log("Login FAILED (not authorized):" + id);
    //     return cb(Error("User not authorized: " + JSON.stringify(id)));
    // }
}

samlStrategy = new SamlStrategy(
    serverConfig.saml.samlStrategy,
    function(profile, done) {
        findShortName(profile, function(err, user) {
            if (err) {
                return done(err);
            }
            return done(null, user);
        });
    })

if (serverConfig.saml.enabled)
    passport.use(samlStrategy);

console.log(samlStrategy.generateServiceProviderMetadata());

// Local users login setup --------------
// NOTE: not for production use! Cleartext passwords used and storted in the session.

var findByUsername = function(username, cb) {
    records = serverConfig.localUsers.users;
    for (var i = 0, len = records.length; i < len; i++) {
        var record = records[i];
        if (record.username === username) {
            return cb(null, record);
        }
    }
    return cb(null, null);
}


var Strategy = require('passport-local').Strategy;

if (serverConfig.localUsers.enabled)
    passport.use(new Strategy(
        function(username, password, cb) {
            findByUsername(username, function(err, user) {
                if (err) {
                    return cb(err);
                }
                if (!user) {
                    return cb(null, false);
                }
                if (user.password != password) {
                    return cb(null, false);
                }
                return cb(null, {username: username, loginMethod:'local'});
            });
        }));


// Session validation ---------------

passport.serializeUser(function(user, cb) {
    // console.log('serialize called ' + user);
    cb(null, user);
});

passport.deserializeUser(function(id, cb) {
    // console.log('deserialize called');
    
    // isAuthorized = (id.shortName && serverConfig.authorizedUsers.indexOf(id[serverConfig.saml.uniqueUserIdAttributeName])) > -1 || (id.username && serverConfig.authorizedUsers.indexOf(id.username) > -1);
    // if (isAuthorized) {
    //     cb(null, id);
    // } else {
    //     return cb(Error("User not authorized: " + JSON.stringify(id)));
    // }

    cb(null, id);
});


// Core server -------


// Create a new Express application.
var app = express();

var nocache = require('nocache');
app.use(nocache());

// Insecure on production. Use only for development! (CSRF)
if (serverConfig.cors.enabled) {
    // this is for debugging purposes
    app.use(cors({
        credentials: true,
        origin: [serverConfig.baseUrl, 'http://localhost:3000'],
        methods: serverConfig.cors.methods
    }));
}

app.use(function(req, res, next) {
    res.header('X-Frame-Options', "deny");
    res.header('Strict-Transport-Security', "max-age=3153600");
    res.header("Content-Security-Policy", "default-src 'self'; style-src 'self' https://cdnjs.cloudflare.com https://fonts.googleapis.com https://127.0.0.1 https://localhost 'unsafe-inline'; font-src * data:; img-src 'self' https://semantic-ui.com data:");
    next();
});

// Session store
var session = require('express-session');
var MongoDBStore = require('connect-mongodb-session')(session);
mongoSessionUrl = "mongodb://session:" + credentials.mongo_session_password + "@" + serverConfig.mongodb.host + ":" + serverConfig.mongodb.port + "/" + "pentest-sessions"

var sessionStore = new MongoDBStore({
          uri: mongoSessionUrl,
          databaseName: 'pentest-sessions',
          collection: 'sessions'
});
// Catch errors
sessionStore.on('error', function(error) {
	assert.ifError(error);
	assert.ok(false);
});

// Configure view engine to render EJS templates.
//app.set('views', __dirname + '/views');
//app.set('view engine', 'ejs');

// Use application-level middleware for common functionality, including
// logging, parsing, and session handling.
app.use(require('morgan')('combined'));
app.use(require('cookie-parser')());

var bodyParser = require('body-parser');
app.use(bodyParser.json({
    limit: '50mb'
}));
app.use(bodyParser.urlencoded({
    extended: true,
    limit: '50mb'
}));
serverConfig.session.secret = credentials.node_session_secret;
serverConfig.session.store = sessionStore;
app.use(require('express-session')(serverConfig.session));

// Initialize Passport and restore authentication state, if any, from the
// session.
app.use(passport.initialize());
app.use(passport.session());


// =========== ANONYMOUS API (no login required) =============

// Session fixation prevention. Passport does not do it for some crazy reasons...
// https://github.com/jaredhanson/passport/issues/192
var refreshSession = function(req, res, next) {
    var temp = req.session.passport;
    req.session.regenerate(function(err){
        req.session.passport = temp;
        req.session.save(function(err){
            next();                            
        });
    })
}
//    req.session.regenerate(()=>{console.log('new session created');req.session.save(()=>next())});

// SAML login API
app.post(serverConfig.saml.callbackUrl,
    passport.authenticate('saml', {
        failureRedirect: '/',
        failureFlash: true
    }),
    function(req, res) {
        console.log('redirect goes here - JACEK');
        res.redirect('/');
    }
);

app.get('/login/saml',
    refreshSession,
    passport.authenticate('saml', {
        failureRedirect: '/',
        failureFlash: true
    }),
    function(req, res) {
        res.redirect('/');
    }
);

// Local login API
if (serverConfig.localUsers.enabled) {
    app.post('/login/local',
        refreshSession,
        passport.authenticate('local', {
            failureRedirect: '/login/failed'
        }),
        function(req, res) {
            console.log("after login:");
            console.log(req.session);
            res.redirect('/');
        });
}

// whoami
app.get('/login/whoami', function(req, res) {
    if (req.isAuthenticated()) {
        if ('password' in req.user)
            req.user.password = '******************';
        res.json({
            loggedIn: true,
            user: req.user,
	    environment: serverConfig.environmentSuffix
//        publicConfiguration: serverConfig.publicConfiguration || {}
        });
    } else {
        res.json({
            loggedIn: false,
	    environment: serverConfig.environmentSuffix
//        publicConfiguration: serverConfig.publicConfiguration || {}
        });
    }
});

app.get('/config/public', function(req, res) {
    res.json(clientConfig.publicConfiguration || {});
}); 


// Static HTML
app.use(express.static(serverConfig.clientApp.localPath));

// =========================================================

// IMPORTANT: authenticated means e.g. logged in with ANY RANDOM SAML account. The user may not have any access though!
var ensureAuthenticated = function(req, res, next) {
    if (!req.isAuthenticated || !req.isAuthenticated()) {
        return res.json({success: false, error: "not_authenticated", message: "Not authenticated or session expired. Changes are NOT SAVED."})
    }
    next();
}

// Checks if a superuser with access to everything.
var isAuthorizedForEverything = function(username) {
    let permissions = serverConfig.permissions;
    for(perm of permissions) {
        var isUserListed = (perm.users.indexOf(username) > -1);
        if(!isUserListed) 
            continue;

        if(perm.type =='read_write_all') {
                return true;
        }
    }
    return false;
}

// pentestId and pentestRecord can be null if checkAnyAccess=true; It will then test if the user has any access to the app.
var isAuthorizedForPentestRecord = function(username, pentestId, pentestRecord, checkAnyAccess=false) {
    let permissions = serverConfig.permissions;


    // console.log("XXXXXX testing authorization: " + pentestId);
    for(perm of permissions) {
         

        var isUserListed = (perm.users.indexOf(username) > -1);
        if(!isUserListed) 
            continue;

        if(checkAnyAccess) {
            return true; // ANY single record in place for that user, access granted for overall access to the app
        } else {
            if(!pentestRecord || !pentestId)
                return false;
        }
        
        // console.log("testing authorization, user listed: " + perm.type);
        switch(perm.type) { 
            // Access to all pentests
            case 'read_write_all': 
                console.log('Authorization GRANTED, read_write_all: ' + username);
                return true;
                break;

            // Access to all pentests with pentest start date set to the date range
            case 'read_write_between_dates': 
                // console.log(pentestRecord);
                var pentestDate = Date.parse(pentestRecord.dateStarted);
                if(isNaN(pentestDate)) {
                    console.log('Authorization GRANTED, read_write_between_date, no date: ' + username);
                    return true; // NOTE: no date in a pentest means GRANT access. Would lose access to fresh recrods otherwise.
                }

                // console.log(pentestRecord);
                var isDateRangeValid = (Date.parse(perm.pentestDateFrom) <= pentestDate && pentestDate <= Date.parse(perm.pentestDateTo));
                if(isDateRangeValid) {
                    console.log('Authorization GRANTED, read_write_between_date: ' + username);
                    return true;
                }
                break;

            // Access to those pentests that are assinged to the user in the properites readWriteAccess field.
            case 'read_write_only_assigned': 
                // console.log(pentestRecord);
                accessList = pentestRecord.readWriteAccess;
                if(accessList && accessList instanceof Array && accessList.includes(username) ) {                
                    console.log('Authorization GRANTED, read_write_only_assigned: ' + username);
                    return true;
                }
                break;
        }
    }
    //console.log('Authorization DENIED: ' + username);
    //console.log(permissions);
    return false;
}

 
var queryPentest = function(pentestId) {
    return new Promise(function(resolve, reject) {
        let pentests = db.collection('pentests');
        pentests.find({"_id": pentestId}).toArray(function(err,docs){
            if(err) {
                reject(err);
                return;
            }
            if(docs.length>1) {// ensure exactly one
                reject(err);
                return;
            }
            if(docs.length==0) { // no entry is an important response
                resolve(null);
                return;
            }
            resolve(docs[0]);   
        });
    });
};

// var queryPentest = function(pentestId, cb) {
//     let pentests = db.collection('pentests');
//     pentests.find({"_id": pentestId}).toArray(function(err,docs){
//         if(err)
//             return cb(err,null);
//         if(docs.length>1) // ensure exactly one
//             return cb(err,null);
//         if(docs.length==0) // no entry is an important response
//             return cb(null,null);   

//         return cb(null,docs[0]);   
//         //console.log('Pentest details ('+pentestId+'); ' + JSON.stringify(docs,null,4) );
//     });
// }

// resovles only if authorizes
var isAuthorizedForPentest = function(username, pentestId) {
    return new Promise((resolve, reject) => { 
        queryPentest(pentestId)
            .then(pentestRecord=>{
                if(isAuthorizedForPentestRecord(username, pentestId, pentestRecord)) {
                    return resolve();
                }
                reject();

            })
            .catch(err=>reject(err));
    });
}

// Rejects users with not authorization to ANYTHING in the app.
var ensureHasAnyAuthorizations = function(req, res, next) {
    let username = req.user.username;
    if(!username) {
        console.log('Access denied: '+username);
        return res.json({success: false, error: "internal error", message: "Authorization internal error."})
    }

    var hasAnyAccess = isAuthorizedForPentestRecord(username, null, null, true); // check if ANY access to the app is granted to the user.
    if(!hasAnyAccess) {
        console.log('Access denied: '+username);
        return res.json({success: false, error: "Access denied", message: "No access"});
    }
    next();
}

// Whitelisting APIs accessible by users. New plugins will fail if the new APIs don't get whitelisted here and are called by non-admins.
var ensureAuthorized = function(req, res, next) {

    // console.log("XXXX");
    let username = req.user.username;
    if(!username) {
        return res.json({success: false, error: "internal error", message: "Authorization internal error."})
    }

    var hasAnyAccess = isAuthorizedForPentestRecord(username, null, null, true); // check if ANY access to the app is granted to the user.
    if(!hasAnyAccess) {
        console.log('Access denied, ensureAuthorized: '+username);
        return res.json({success: false, error: "Access denied", message: "No access"});
    }

    // console.log(JSON.stringify(req.path,null,4));
    let path = req.path.split('/');
    // if(path[path.length-1]==="") {
    //     path.pop(); // 
    // } 
    
    // TODO: Handle OPTIONS for x-domain development of the UI.


    let isMongoApi = path[1]=='api' && path[2]=='v1';
    if(isMongoApi) {
        switch(path[3]) {
            // pentests 
            case 'pentests':
                if(path.length==4 || path[4]==='') {
                    if(req.method=='GET') { // || req.method=='POST') { // we don't use POST
                        req.path='/api/v1/pentests'; // just to be safe
                        return next(); // TODO: scope the list of tests
                    } else {
                        console.log('Access denied, mongoapi: '+username);
                        return res.json({success: false, error: "Access denied", message: "No access"})
                    }
                } else {
                    let pentestId = path[4];
                    if(req.method=='GET' || req.method=='PUT' || req.method=='DELETE') {
                        queryPentest(pentestId)
                            .then(pentestDetails=>{                            
                                if(pentestDetails==null && req.method=='PUT') { // this pentestID does not exist yet
                                    return next();
                                } 
                                if(isAuthorizedForPentestRecord(username, pentestId, pentestDetails, false)) {
                                    return next(); 
                                    // TODO: hidden assumption: there are no OR conditions in mongo-rest-api queries; priv esc otherwise.
                                } else {
                                    console.log('Access denied, mongoapi (2): '+username);
                                    return res.json({success: false, error: "Access denied", message: "No access"});
                                }
                            })
                            .catch(err=>{    
                                res.json({success: false, error: "Access denied", message: "Pentest not found"});
                            });
                    } else {
                        console.log('Access denied, mongoapi (3): '+username);
                        return res.json({success: false, error: "Access denied", message: "No access"})
                    }
                }
                break; 
            
            // others
            case 'actions':
            case 'timeline':
            case 'knowledge':
            case 'findings':
            case 'reporting':  
                
                // console.log(path[3]);
                let pentestId = req.query.pentest_id;
                if(!pentestId && req.method == 'GET') {
                    // Must query for a single pentest unless an admin

                    // if(path[3] == 'findings' && isAuthorizedForEverything(username)) {
                    //     // exception to get a list of findings to clone
                    //     return next();
                    // }

                    console.log('Access denied, other APIs: '+username);
                    return res.json({success: false, error: "Access denied", message: "No access"})
                }
                
                if(req.method == 'PUT') {
                    //console.log(req.body);
                    pentestId = req.body.pentest_id;
                    // TODO: if duplicate keys are handeld differently in node than in mongodb, privesc here via duplicated pentest_id entry. Would be ideal to reserialize here.
                    // TODO2: BUG: we should verify that the node does not exist yet. Otherwise: privesc: overwrite an existing entry if one guesses the random id (e.g. PUT /api/v1/actions/YQIFHIJr66uVV6SmXTjurq1ZwOmujW)
                }

                // console.log('checkingIfAuthorized');
                isAuthorizedForPentest(username, pentestId)
                    .then(() => next())
                    .catch(err=> {
                        console.log('Access denied, other APIs (2): '+username);
                        return res.json({success: false, error: "Access denied", message: "No access"});
                    });
                
                break;
            case 'getClones': // custom logic here
                var hasAnyAccess = isAuthorizedForPentestRecord(username, null, null, true); // check if ANY access to the app is granted to the user.
                if(hasAnyAccess) {
                    return next();
                } else {
                    console.log('Access denied, getClones'+username);
                    return res.json({success: false, error: "Access denied", message: "No access"})
                }
                break;
            default:
                console.log('Access denied, default '+username);
                return res.json({success: false, error: "Access denied", message: "No access"})
        }
    } else { // not mongo API
        switch(path[1]) {
            case "actionfiles":
                return next();
                break;
            case "login":
                if(path[2]=="logout")
                    return next();
                break;
            case "config":
                if(path[2]=="postauth")
                    return next();
                break;
            default:
                console.log('Access denied, default non-mongo: '+username);
                return res.json({success: false, error: "Access denied", message: "No access"});
        }
        return res.json({success: false, error: "Access denied", message: "No access"});
    }
 
    //return res.json({success: false, error: "Access denied", message: "Not authorized"});

    // if (!req.isAuthenticated || !req.isAuthenticated()) {
    //     return res.json({success: false, error: "not_authenticated", message: "Not authenticated or session expired. Changes are NOT SAVED."})
    // }
    // next();
}

// ========== PLUGINS ==============
// they are responsible for defining their authorizations on their own. By default, they allow ANONYMOUS ACCESS to their stuff!

// Load all .js files form the ./plugins/ folder. Call register() on them.
var env = {credentials: credentials, serverConfig: serverConfig, app: app, queryPentest: queryPentest, isAuthorizedForPentest: isAuthorizedForPentest, ensureAuthenticated: ensureAuthenticated, ensureHasAnyAuthorizations: ensureHasAnyAuthorizations, ensureAuthorized: ensureAuthorized, mongourl: mongourl, expressMongoRest: expressMongoRest};

function LoadModules(path) {
    var stat = fs.lstatSync(path)
    if (stat.isDirectory()) {
        var files = fs.readdirSync(path);
        var f, l = files.length;
        for (var i = 0; i < l; i++) {
            f =  files[i];
            if (f.substr(-3,3) == '.js') {
                console.log('Loading plugin: ' + f)
            var plugin = require(path + f);
            if ('register' in plugin)
                plugin.register(env);
            }
        }
        
    }

}

LoadModules('./plugins/');


// =========== APIs REQUIRING AUTHENTICATION / AUTHORIZATION below =============

console.log("REGISTERING AUTH");
app.use('/', ensureAuthenticated);
app.use('/', ensureHasAnyAuthorizations);
app.use('/', ensureAuthorized);

// MongoDB REST API
// if (serverConfig.apiRequiresAuthentication)
//     app.use('/api/v1', ensureAuthenticated);

app.get('/api/v1/getClones', function (req, res, next) {
    var query = query2m(
        { '_deleted!': 'true',
            fields: 'id,pentest_id,name,description,remediation,score' 
        }
        , { ignore: 'envelope' });

    let username = req.user.username;

    // 1) Find all pentests we are authorized to see
    let pentests = db.collection('pentests');
    pentests.find({}).toArray(function(err,docs){ 
        if(err) {
            return res.json({success: false, error: "Access denied", message: "No access"});return cb(err,null);
        }
        var authorizedPentestIds = filterPentestListWithAuthorization(username, docs).map(pentest=>pentest._id);
        console.log('Authorized to see: '+authorizedPentestIds);

        let findings = db.collection('findings');
        findings.find(query.criteria, query.options).toArray(function(err,fin){
            if(err) {
                return res.json({success: false, error: "Internal error", message: "Internal error"});
            }
            let filtered = fin.filter(f=>authorizedPentestIds.includes(f.pentest_id));
            return res.json(filtered);
        });

    }); 
    return;
});

var filterPentestListWithAuthorization = function (username, list, pentestIdAttributeName="_id") {
    // console.log('LIST: '+list);
    return list.filter(function(pentestRecord) {
        return isAuthorizedForPentestRecord(username, pentestRecord[pentestIdAttributeName], pentestRecord, false);
    });
}

// Filters results of the MongoDB request if a request is for /api/v1/pentests/. Hides pentests one has no access to.
var filteredMongoRest = function(mongorest) {
    return function(req, res, next) {
        let username = req.user.username;
        // console.log('FILTERING '+req.path);
        
        if(req.path=='/pentests' || req.path=='/pentests/') {
            // TODO: BUG: bypasses of it are very likely. 
            // console.log('FILTERING');

            let pentests = db.collection('pentests');
            pentests.find({}).toArray(function(err,docs){
                if(err) {
                    console.log('Access denied, default non-mongo: '+username);
                    return res.json({success: false, error: "Access denied", message: "No access"});return cb(err,null);
                }
                
                // console.log("type: " + (typeof docs));
                return res.json(filterPentestListWithAuthorization(username, docs));
                //console.log('Pentest details ('+pentestId+'); ' + JSON.stringify(docs,null,4) );
            });
            return;
        }
        return mongorest(req, res, next);
    };
}

app.use('/api/v1', filteredMongoRest(expressMongoRest(mongourl)));

var headerOverride = function(res, path, stat) {
    //	console.log(res);
    //	res.set('Content-Type', 'text/plain');
}

app.use('/actionfiles', ensureAuthenticated, express.static(serverConfig.actions.sharedFolder, {
    setHeaders: headerOverride
}));


app.get('/config/postauth', function(req, res) {
    res.json(clientConfig.postAuthConfiguration || {});
});

app.get('/login/logout',
    function(req, res) {
        req.logout();
        res.redirect('/');
    });


// error handler

app.use(function (err, req, res, next) {
    console.error(err.stack)
    res.status(500).json({error:'Something broke!'})
})


// https
const https = require('https');
const { constants } = require('crypto')

const options = {
    key: fs.readFileSync(serverConfig.https.keyFile).toString('ascii'),
    cert: fs.readFileSync(serverConfig.https.certFile).toString('ascii'),
    secureOptions: constants.SSL_OP_NO_TLSv1 | constants.SSL_OP_NO_TLSv1_1

};

var port=10443; // port inside docker. Configuration is used to take a port mapped to the outside.
https.createServer(options, app).listen(port); //serverConfig.https.port);
console.log("Server ready, listening on port "+port);
