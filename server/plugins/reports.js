module.exports = {
    register: function({app, serverConfig, ensureAuthenticated, ensureHasAnyAuthorizations, queryPentest, isAuthorizedForPentest ,mongourl}) {

        // takes the pentest id from the POST body, pid attribute - a convention used in this plugin's API.
        var ensureAuthorizedForReport = function(req, res, next) {
            var pentestId = req.body.pid;
            let username = req.user.username;

            isAuthorizedForPentest(username, pentestId)
                .then(()=>{console.log('isauthorized'); next()})
                .catch(err=>res.json({success: false, error: "Access denied", message: "No access"}));
            
        };

        app.post('/generate/archer', ensureAuthenticated, ensureHasAnyAuthorizations, ensureAuthorizedForReport,function(req, res) {
            var Promise = require('bluebird');
            var XlsxTemplate = require('xlsx-template');
            var excel = require('node-excel-export');
            var mongoClient = Promise.promisifyAll(require('mongodb')).MongoClient;
            var pid = req.body.pid;
            var findings = null;
	    var properties = null;
            var fs = require('fs');
            var path = require('path');


            mongoClient.connectAsync(mongourl, {useUnifiedTopology: true})
                .then(function(client) {
                    db = client.db(serverConfig.mongodb.database);
                    return db.collection('pentests').find({
                        "_id": pid
                    });
                    db.close();
                })
                .then(function(cursor) {
                    return cursor.toArrayAsync();
                })
                .then(function(content) {
		    //console.log(content);
                    properties = content || "";
                    //console.log([properties][0]["ae"]);
		    complete();
                })
            .catch(function(err) {
                throw err;
            });


            mongoClient.connectAsync(mongourl, {useUnifiedTopology: true})
                .then(function(client) {
                    db = client.db(serverConfig.mongodb.database);
                    return db.collection('findings').find({
                        "pentest_id": pid,
                        '_deleted': {
                            $ne: true
                        }
                    });
                    db.close();
                })
                .then(function(cursor) {
                    return cursor.toArrayAsync();
                })
                .then(function(content) {
                    findings = content || "";
                    findings = findings.filter(function(finding) { return finding.findingType !== 'Chain' && finding.score !=='Info'; });
                    var order = ["Critical (GIA-Major)", "High", "Medium", "Low", "Info"];
                    findings.sort((a, b) => {
                        var firstOrder = order.indexOf(a.score);
                        var secondOrder = order.indexOf(b.score);
                        return firstOrder - secondOrder;
                    });
                    var nonMajor = {
                        priority: "Non-Major",
                        finimpact: "Non-Major"
                    };
                    var major = {
                        priority: "Major",
                        finimpact: "< $5MM USD"
                    };
                    for (var finding in findings) {
			if (findings[finding]["findingType"] !== undefined) {
			     if (findings[finding]["findingType"] == "Application") {
			          findings[finding].rtheme = "Information Security";
				  findings[finding].control = "Web Server Security";
			     }
                             if (findings[finding]["findingType"] == "Infrastructure") {
				  findings[finding].rtheme = "Information Security";
				  findings[finding].control = "OSM Patch Management";
			     }
			     if (findings[finding]["findingType"] == "Process") {
				  findings[finding].rtheme = "Information Security";
				  findings[finding].control = "Technical Security Standards";
			     }
			} else {
			    findings[finding]["rtheme"] = "Undefined";
			    findings[finding]["control"] = "Undefined";
			}
                        /* if (findings[finding]["rt_ctrl"] !== undefined) {
                            var theme_split = findings[finding]["rt_ctrl"].split(':');
                            findings[finding].rtheme = theme_split[0];
                            findings[finding].control = theme_split[1];
                        } else {
                            findings[finding]["rtheme"] = "Undefined";
                            findings[finding]["control"] = "Undefined";
                        }

                        if (findings[finding]["owasp"] == undefined) {
                            findings[finding]["owasp"] = "Undefined";
                        }
                        if (findings[finding]["bus_imp"] == undefined) {
                            findings[finding]["bus_imp"] = "Undefined";
                        }
			*/

			findings[finding].iss_desc = "PEN TEST - " + findings[finding]["pentest_id"];
			//findings[finding].iss_desc = "PEN TEST - " + findings[finding]["pentest_id"] + "; " + findings[finding]["owasp"] + "; " + findings[finding]["bus_imp"];
			findings[finding].src_type = "Second Line of Defense";
            findings[finding].src = "Penetration Testing";
 			findings[finding].cause = "Inadequate or Incomplete Policy Deployed";

                        if (findings[finding]["score"] !== undefined) {
                            if (findings[finding]["score"].indexOf("GIA-Major") > -1) {
                                findings[finding]["priority"] = "Major";
                                findings[finding]["finimpact"] = "< $5MM USD";
                            } else {
                                findings[finding]["priority"] = "Non-Major";
                                findings[finding]["finimpact"] = "Non-Major";
                            }
                        } else {
                            findings[finding]["priority"] = "Undefined";
                            findings[finding]["finimpact"] = "Undefined";
                        }
                    }
                    complete();
                })
                .catch(function(err) {
                    throw err;
                });

            function complete() {
                if (findings !== null && properties !== null) {
		    for (var finding in findings) {
			if (findings[finding]["name"] !== undefined) {
			    findings[finding].ae = properties[0].ae;
			    findings[finding].app_mgr = properties[0].app_mgr;
			    findings[finding].iss_approver = properties[0].iss_approver;
                findings[finding].projectLeader = properties[0].projectLeader;
			}
	            }
                    // Load an XLSX file into memory
                    fs.readFile(path.join(__dirname, serverConfig.extensions.reports.archerTemplate), function(err, data) {

                        // Create a template
                        var template = new XlsxTemplate(data);

                        // Replacements take place on first sheet
                        var sheetNumber = 1;

                        // Set up some placeholder values matching the placeholders in the template
                        var values = {
                            findings: findings,
			    properties: properties
                        };

                        // Perform substitution
                        template.substitute(sheetNumber, values);

                        // Get binary data
                        var buf = template.generate({
                            type: 'nodebuffer'
                        });

                        // ...

                        var fileName = 'Archer_' + pid.replace(/ /g, "_") + '.xlsx';

                        // buf is a nodejs buffer, you can either write it to a file or do anything else with it.
                        fs.writeFileSync(path.resolve(__dirname, 'output.xlsx'), buf);

                        res.set('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
                        res.set('Content-disposition', 'attachment; filename=' + fileName);
                        res.set('Transfer-Encoding', 'chunked');
                        var outFile = fs.readFileSync(path.resolve(__dirname, 'output.xlsx'));
                        res.send(new Buffer(outFile.toString('base64')));
                    });
                }
            }

        });

        // todo: add ensureAuthenticated to /generate once local user disabled. Does not work with local user
        app.post('/generate/report', ensureAuthenticated, ensureHasAnyAuthorizations, ensureAuthorizedForReport, function(req, res) {

            console.log('GENERATING REPORT 1');
            var Promise = require('bluebird');
            var mongoClient = Promise.promisifyAll(require('mongodb')).MongoClient;
            var pid = req.body.pid;
   	    var rType = req.body.rType;
            var properties = null;
	    var reporting = null;
            var findings = null;
            var snapshot = null;
            var fyiSnapshot = null;
            var appFindings = null;
            var infFindings = null;
            var proFindings = null;
            var fyiFindings = null;
            var chainFindings = null;
            var t_entries = null;
            var clientConn = null;
            var dbConn = null;
            var defCount = 0;
            var definitions = [];
            var _ = require('underscore');

            mongoClient.connectAsync(mongourl, {useUnifiedTopology: true})
                .then(function(client) {
                    db = client.db(serverConfig.mongodb.database);
                    return db.collection('pentests').find({
                        "_id": pid
                    })
                    db.close();
                })
                .then(function(cursor) {
                    return cursor.toArrayAsync();
                })
                .then(function(content) {
                    properties = content || "";
                    complete();
                })
                .catch(function(err) {
                    throw err;
                });

            console.log('GENERATING REPORT 2');
            mongoClient.connectAsync(mongourl, {useUnifiedTopology: true})
                .then(function(client) {
                    db = client.db(serverConfig.mongodb.database);
                    return db.collection('reporting').find({
                        "pentest_id": pid
                    })
                    db.close();
                })
                .then(function(cursor) {
                    return cursor.toArrayAsync();
                })
                .then(function(content) {
                    reporting = content || "";
                    complete();
                })
                .catch(function(err) {
                    throw err;
                });

            console.log('GENERATING REPORT 3');
            mongoClient.connectAsync(mongourl, {useUnifiedTopology: true})
                .then(function(client) {
                    db = client.db(serverConfig.mongodb.database);
                    return db.collection('timeline').find({
                        'pentest_id': pid,
                        '_deleted': {
                            $ne: true
                        }
                    }).sort({
                        tl_date: 1
                    });
                    db.close();
                })
                .then(function(cursor) {
                    return cursor.toArrayAsync();
                })
                .then(function(content) {
                    t_entries = content || "";
                    var dateFormat = require('dateformat');
                    for (var entry in t_entries) {
                        var oDate = new Date(t_entries[entry]["tl_date"]);
                        oDate = oDate.setHours(oDate.getHours());
                        var nDate = dateFormat(oDate, "ddd mm/dd/yy h:MM TT");
                        t_entries[entry]["tl_date"] = nDate;
                    }
                    complete();
                })
                .catch(function(err) {
                    throw err;
                });

            console.log('GENERATING REPORT 4');
            mongoClient.connectAsync(mongourl, {useUnifiedTopology: true})
                .then(function(client) {
                    db = client.db(serverConfig.mongodb.database);
                    return db.collection('findings').find({
                        "pentest_id": pid,
                        '_deleted': {
                            $ne: true
                        }
                    });
                    db.close();
                })
                .then(function(cursor) {
                    return cursor.toArrayAsync();
                })
                .then(function(content) {
		    findings = content || "";
                    var order = ["Critical (GIA-Major)", "High", "Medium", "Low", "Info"];
                    findings.sort((a, b) => {
                        var firstOrder = order.indexOf(a.score);
                        var secondOrder = order.indexOf(b.score);
                        return firstOrder - secondOrder;
                    });

                    snapshotAll = JSON.parse(JSON.stringify(findings));;
                    snapshot = snapshotAll.filter(function(snap) { return snap.findingType !== 'Chain' && snap.score!=='Info'; });
                    fyiSnapshot = snapshotAll.filter(function(snap) { return snap.findingType !== 'Chain' && snap.score=='Info'; });

                    var format = function(list, fontSize) {
                        for (var element in list) {
                            if (list[element]["description"] !== undefined) {
                                list[element]["description"] = replaceNewLines(list[element]["description"], fontSize);
                            }
                            if (list[element]["remediation"] !== undefined) {
                                list[element]["remediation"] = replaceNewLines(list[element]["remediation"], fontSize); 
                            }
                            if (list[element]["retestNotes"] !== undefined) {
                                list[element]["retestNotes"] = replaceNewLines(list[element]["retestNotes"], fontSize); 
                            }
                        }
                    }

                    format(findings, 11);
                    format(snapshot, 9);
                    format(fyiSnapshot, 9);

                    filterFun = function(type) { return (function(x) {return x.findingType === type && x.score!=='Info'});}
                    filterChain = function(type) { return (function(x) {return x.findingType === type});}
                    filterFYI = function(score) { return (function(x) {return x.score === score && x.findingType!=='Chain'});}
                    appFindings = _.filter(findings, filterFun('Application'));
                    infFindings = _.filter(findings, filterFun('Infrastructure'));
                    proFindings = _.filter(findings, filterFun('Process'));
                    chainFindings = _.filter(findings, filterChain('Chain'));
                    fyiFindings = _.filter(findings, filterFYI('Info'));
                    complete();
                    
                })
                .catch(function(err) {
                    throw err;
                });

            console.log('GENERATING REPORT 5');
            mongoClient.connectAsync(mongourl, {useUnifiedTopology: true})
                .then(function(client) {
                    db = client.db(serverConfig.mongodb.database);
                    clientConn = client;
                    dbConn = db;
                    defCount = db.collection('definitions').countDocuments();
                    Promise.resolve(defCount).then(function(value) {
                        defCount = value
                    }, function(value) {});
                    return db.collection('definitions').findAsync({});
                })
                .then(function(cursor) {
                    var count = -1;
                    var promises = [];
                    var a;
                    var b;

                    return new Promise((resolve, reject) => {
                        console.log('GENERATING REPORT building tasks queue');

                        cursor.each(function(err, doc) {
                            if (doc !== null) {

                                promises.push(new Promise((res, rej) => dbConn.collection('pentests').findAsync({
                                        _id: pid,
                                        $text: {
                                            $search: "\"" + doc.Word + "\""
                                        }
                                    })
                                    .then(function(pWords) {
                                        return pWords.toArrayAsync();
                                    })
                                    .then(function(pwMatch) {
                                        if (pwMatch.length > 0) {
                                            definitions.push(doc);
                                        }
                                        res("resolved");
                                    })
                                    .catch(err => console.log('Catch', err))));

                                promises.push(new Promise((res, rej) => dbConn.collection('pentests').findAsync({
                                        _id: pid,
                                        $text: {
                                            $search: "\"" + doc.Abbreviation + "\""
                                        }
                                    })
                                    .then(function(pAbbr) {
                                        return pAbbr.toArrayAsync();
                                    })
                                    .then(function(paMatch) {
                                        if (paMatch.length > 0) {
                                            definitions.push(doc);
                                        }
                                        res("resolved");
                                    })
                                    .catch(err => console.log('Catch, err'))));

                                promises.push(new Promise((res, rej) => dbConn.collection('findings').findAsync({
                                        pentest_id: pid,
                                        $text: {
                                            $search: "\"" + doc.Word + "\""
                                        }
                                    })
                                    .then(function(fWords) {
                                        return fWords.toArrayAsync();
                                    })
                                    .then(function(fwMatch) {
                                        if (fwMatch.length > 0) {
                                            definitions.push(doc);
                                        }
                                        res("resolved");
                                    })
                                    .catch(err => console.log('Catch, err'))));

                                promises.push(new Promise((res, rej) => dbConn.collection('findings').findAsync({
                                        pentest_id: pid,
                                        $text: {
                                            $search: "\"" + doc.Abbreviation + "\""
                                        }
                                    })
                                    .then(function(fAbbr) {
                                        return fAbbr.toArrayAsync();
                                    })
                                    .then(function(faMatch) {
                                        if (faMatch.length > 0) {
                                            definitions.push(doc);
                                        }
                                        res("resolved");
                                    })
                                    .catch(err => console.log('Catch, err'))));

                                promises.push(new Promise((res, rej) => dbConn.collection('timeline').findAsync({
                                        pentest_id: pid,
                                        $text: {
                                            $search: "\"" + doc.Word + "\""
                                        }
                                    })
                                    .then(function(tWords) {
                                        return tWords.toArrayAsync();
                                    })
                                    .then(function(twMatch) {
                                        if (twMatch.length > 0) {
                                            definitions.push(doc);
                                        }
                                        res("resolved");
                                    })
                                    .catch(err => console.log('Catch, err'))));

                                promises.push(new Promise((res, rej) => dbConn.collection('timeline').findAsync({
                                        pentest_id: pid,
                                        $text: {
                                            $search: "\"" + doc.Abbreviation + "\""
                                        }
                                    })
                                    .then(function(tAbbr) {
                                        return tAbbr.toArrayAsync();
                                    })
                                    .then(function(taMatch) {
                                        if (taMatch.length > 0) {
                                            definitions.push(doc);
                                        }
                                        res("resolved");
                                    })
                                    .catch(err => console.log('Catch, err'))));
                            }
                            count++;
                            if (count === defCount) {
                                console.log('GENERATING REPORT waiting for all');
                                Promise.all(promises).then(function(values) {
                                    console.log('GENERATING REPORT all done');
                                    resolve(definitions);
                                });
                            }
                        })
                    })
                })
                .then(function(content) {
                    console.log('GENERATING REPORT about to finish');
                    definitions = (definitions.length === 0 ? ["filler"] : content);
                    clientConn.close();
                    console.log('GENERATING REPORT connection closed, running complete');
                    complete();
                })
                .catch(function(err) {
                    throw err;
                });

            //b64 image conversion docxtemplater
            function base64DataURLToArrayBuffer(dataURL) {
                Canvas = require('canvas');
                let im = new Canvas.Image;
                im.onload = function() {
                    imgHeight = im.height;
                    imgWidth = im.width;
                };
                im.src = dataURL;
                const base64Regex = /^data:image\/(png|jpg);base64,/;
                if (!base64Regex.test(dataURL)) {
                    return false;
                }
                const stringBase64 = dataURL.replace(base64Regex, "");
                let binaryString;
                if (typeof window !== "undefined") {
                    binaryString = window.atob(stringBase64);
                } else {
                    binaryString = new Buffer(stringBase64, "base64").toString("binary");
                }
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    const ascii = binaryString.charCodeAt(i);
                    bytes[i] = ascii;
                }

                return bytes.buffer;
            }

            function getDimensions(dataURL) {
                Canvas = require('canvas');
                let im = new Canvas.Image;
                im.onload = function() {
                    imgHeight = im.height;
                    imgWidth = im.width;
                };
                im.src = dataURL;

                if (imgWidth > 700) {
                    var imgDiff = imgWidth - 700;
                    var scaling = (imgWidth - imgDiff )/ imgWidth;
                    imgWidth = Math.floor(scaling*imgWidth);
                    imgHeight = Math.floor(scaling * imgHeight);
                }
                return [imgWidth, imgHeight];
            }

            function replaceNewLines(paragraphData, fontSize) {
                if(!paragraphData)
                    paragraphData="";
                paragraphData = paragraphData.replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&apos;');
                var size = fontSize*2;
                var lines = paragraphData.split("\n");
                var pre = "<w:p><w:r><w:rPr><w:rFonts w:ascii='Calibri (Body)' w:cs='Times New Roman'/><w:sz w:val='" + size + "'/></w:rPr><w:t>";
                var post = "</w:t></w:r></w:p>";
                var lineBreak = "<w:br/>";
                return pre + lines.join(lineBreak) + post;
            }

            function complete() {
                if (properties !== null && findings !== null && t_entries !== null && reporting !== null && definitions.length > 0) {
		    var uDefs = _.uniq(definitions, '_id');


                    console.log('GENERATING REPORT doxtemplater start');
                    //docxtemplater
                    var ImageModule = require('docxtemplater-image-module');
                    var JSZip = require('jszip');
                    var Docxtemplater = require('docxtemplater');

                    var fs = require('fs');
                    var path = require('path');
		    var docFileName = "";
                    var opts = {};
                    opts = {
                        centered: true
                    }
                    opts.getImage = function(tagValue) {
                        return base64DataURLToArrayBuffer(tagValue);
                    }
                    opts.getSize = function(img, tagValue) {
                        var dimensions = getDimensions(tagValue);
                        return [dimensions[0], dimensions[1]];
                    }

                    var imageModule = new ImageModule(opts);

                    //Replace items that could contain new lines with raw XML
                    if (properties[0]["description"] !== undefined) {
                        properties[0]["description"] = replaceNewLines(properties[0]["description"], 11);
                    }
		

                    if (properties[0]["scope_description"] !== undefined) {
                        properties[0]["scope_description"] = replaceNewLines(properties[0]["scope_description"], 11);
                    }
                    for (var entry in t_entries) {
                        if (t_entries[entry]["tl_description"] !== undefined) {
                            t_entries[entry]['tl_description'] = replaceNewLines(t_entries[entry]['tl_description'], 9);
                        }
                    }
                    if (reporting[0]["exec_summary"] !== undefined) {
                        reporting[0]["exec_summary"] = replaceNewLines(reporting[0]["exec_summary"], 11);
                        if (reporting[0]["exec_summary_retest"] !== undefined) {
                            reporting[0]["exec_summary_retest"] = replaceNewLines(reporting[0]["exec_summary_retest"], 11);
                        }
                    } else {
                        reporting = {};
                        reporting[0] = [];
                        var data = { exec_summary: "", exec_summary_retest: "" };
                        reporting[0].push(data);
                    }


                    if (rType == "vendor") {
                        docFileName = serverConfig.extensions.reports.vendorTemplate;
                    } else if(rType == "iot") {
                        docFileName = serverConfig.extensions.reports.iotTemplate;
                    } else if(rType == "retest") {
                        docFileName = serverConfig.extensions.reports.retestTemplate;
                    } else {
                        docFileName = serverConfig.extensions.reports.pentestTemplate;
                    }

                    console.log('GENERATING REPORT loading file as binary');

                    //Load the docx file as a binary
                    var content = fs
                        .readFileSync(path.resolve(__dirname, docFileName), 'binary');

                    var zip = new JSZip(content);

                    var concatNames = function(arr) {
                        if(!arr) return "";
                        if(arr.length == 0) return "";
                        if(arr.length == 1) return arr[0];
                        last = arr.pop();
                        ret = arr.join(', ') + ' and ' + last;
                        arr.push(last);
                        return ret;
                    }

                    console.log('GENERATING REPORT templater instance');

                    var doc = new Docxtemplater();
                    doc.attachModule(imageModule);
                    doc.loadZip(zip);
                    //set the templateVariables
                    doc.setData({
                        properties: properties,
                        findings: findings,
                        appFindings: appFindings,
                        infFindings: infFindings,
                        proFindings: proFindings,
                        chainFindings: chainFindings,
                        fyiFindings: fyiFindings,
                        snapshot: snapshot,
                        fyiSnapshot: fyiSnapshot,
                        tl_entries: t_entries,
                        pentest_name: properties[0]['name'],
                        pentest_leader: properties[0]['projectLeader'],
                        executive_summary: reporting[0]['exec_summary'],
                        exec_summary_retest: reporting[0]['exec_summary_retest'], 
			            scope_description: properties[0]['scope_description'],
                        team_members: concatNames(properties[0]['teamMembers']),
                        components: properties[0]['components'],
                        hosts: properties[0]['hosts'],
                        definitions: uDefs,
			            page_break: '<w:p><w:br w:type="page" /></w:p>'
                    });
//                    console.log(JSON.stringify(snapshot,null,4));
                    try {
                        // render the document (replace all occurences of {first_name} by John, {last_name} by Doe, ...)
                        console.log('GENERATING REPORT calling render');

                        doc.render();

                        console.log('GENERATING REPORT  render done');
                    } catch (error) {
                        var e = {
                            message: error.message,
                            name: error.name,
                            stack: error.stack,
                            properties: error.properties,
                        }
                        console.log(JSON.stringify({
                            error: e
                        }));
                        // The error thrown here contains additional information when logged with JSON.stringify (it contains a property object).
                        throw error;
                    }
                    var fileName = pid.replace(/ /g, "_") + docFileName;

                    console.log('GENERATING REPORT zipping');
                    var buf = doc.getZip()
                        .generate({
                            type: 'nodebuffer'
                        });

                    console.log('GENERATING REPORT saving to file');

                    // buf is a nodejs buffer, you can either write it to a file or do anything else with it.
                    fs.writeFileSync(path.resolve(__dirname, '/tmp/output.docx'), buf);

                    res.set('Content-Type', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document');
                    res.set('Content-disposition', 'attachment; filename=' + fileName);
                    res.set('Transfer-Encoding', 'chunked');
                    var outFile = fs.readFileSync(path.resolve(__dirname, '/tmp/output.docx'));

                    console.log('GENERATING REPORT sending back');
                    res.send(new Buffer(outFile.toString('base64')));
                    console.log('GENERATING REPORT send done');

                }
            }
        });



    }
};
