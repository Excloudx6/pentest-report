from pymongo import MongoClient
import time
import sys
import json
import os

class Action:
    def __init__(self, actionName, dependentActionTypes):
        """e.g. 'port_scan', ['full_scan_trigger','foo'] """

        self.__conf = json.load(open("../config/default.json"))
        creds = json.load(open("../config/credentials.json"))

        mongourl = "mongodb://" + self.__conf['PentestServer']['mongodb']['host'] + ":" + str(self.__conf['PentestServer']['mongodb']['port']) + "/" + self.__conf['PentestServer']['mongodb']['database'] 

        #print (mongourl)

        self.__client = MongoClient(mongourl, username='actions', password=creds['credentials']['mongo_actions_password'])
        self.__db = self.__client[self.__conf['PentestServer']['mongodb']['database'] ]
        self.__actions = self.__db.actions
        self.__pentests = self.__db.pentests

        self.dependencies = dependentActionTypes 
        self.name = actionName
        
        self.__files = []

    def __isPresent(self, actionName, actions):
        for a in actions:
            if actionName == a['name']:
                return True
        return False

    def __dictionaryFromActions(self, actions, trigger):
        """Returns a dictionary indexed with action names out of actions cursor and the trigger action"""
        dictionary = {}
        if 'name' in trigger:
            dictionary[trigger['name']] = trigger
            dictionary['_trigger'] = trigger  # An additional fixed key (for jobs convinience).

        for a in actions:
            # print('processing action to dict: {}'.format(a['name']))
            if 'name' in a:
                dictionary[a['name']] = a
        return dictionary
            
    def __createStartedAction(self, pentest, trigger):
        """ Creates a new action entry - placeholder for a job that is just about to run. """

        newAction = {'name': self.name, 'pentest_id': pentest['_id'], 'trigger_id': trigger['_id'], 'status': 'started', 'created_at': time.time(), 'updated_at': time.time()}
        return self.__actions.insert_one(newAction).inserted_id

    def __updateFinishedAction(self, actionId, result):
        """ result - {'status': ..., 'result': ..., [error: ...]} """
        action = self.__actions.find_one({"_id": actionId});
        if not result:
            action['status'] = 'failed'
            action['error'] = 'Job returned nothing'
        elif 'status' not in result:
            action['status'] = 'failed'
            action['error'] = 'Job did not return status'
        else:
            action['status'] = result['status']
            action['result'] = result['result']
            if 'error' in result:
                action['error'] = result['error']
        action['updated_at'] = time.time()
        action['files'] = self.__files

        self.__actions.replace_one({'_id': action['_id']}, action)

    def getOutputPath(self):
        """ Action output files should be placed in the folder returned. They will be accessible from the web UI. """
        path = self.__conf['PentestServer']['actions']['sharedFolder'] + "/" + str(self.__actionId) + "/"
        os.mkdir(path)
        return path

    def reportOutputFile(self, filepath):
        """ To show an action generated file explicitly to the user in the web UI, report it via this mehtod. Optional. Files not reported will still be stored and accessbile, but will not have explicit links shown to the users. Report file with path relative to the folder returned by getOutputPath(), e.g. "foo/bar.html" or "report.html". """
        self.__files.append({'file_path': filepath, 'file_type': "none" })

    def reportProgress(self, progress):
        """ Use it optionally to report action progress. """
        """ progress - by convention, use dictionary with at these attributes: percentage (number), description (string) """

        action = self.__actions.find_one({"_id": self.__actionId});
        action['updated_at'] = time.time()
        action['progress'] = progress
        self.__actions.replace_one({'_id': action['_id']}, action)


    def scan(self):
        """ Performs a single round of checking if the job can be executed against something. Coordinates running the job and savingstates and results in the database """

        # TODO: exclude deleted pentests?
        for pentest in self.__pentests.find():
            # print('Scanning pentest: ' + pentest['_id'])
            triggers = self.__actions.find({'pentest_id': pentest['_id'], 'is_trigger': True, 'deleted': {'$ne': True}})
            for trigger in triggers:

                # print('  Processing trigger: ' + trigger['_id'])

                # Hint: '$ne': True captures also those cases where the attribute is not present at all
                f = {'pentest_id': pentest['_id'], 'is_trigger': {'$ne': True}, 'status': {'$in': ['done', 'started', 'died', 'error']}, 'trigger_id': trigger['_id'], 'name': self.name, 'deleted': {'$ne': True}}
                identicalActions = self.__actions.find(f)
                # print('  Identical actions: {} ({}, {})'.format(identicalActions.count(), self.name, pentest['_id']))
                if (identicalActions.count()>0 and not self.ignorePreviousRuns()):
                    # print('Action done already. Skipping.') #  + str(identicalActions[0]))
                    continue

                otherActions = list(self.__actions.find({'pentest_id': pentest['_id'], 'is_trigger': {'$ne': True}, 'status': 'done', 'trigger_id': trigger['_id'], 'deleted': {'$ne': True}}))
                #print(otherActions)

                dependenciesMet = True
                for dep in self.dependencies:
                    if ('name' in trigger and dep == trigger['name']) or self.__isPresent(dep, otherActions):
                        continue
                    dependenciesMet = False
                    break

                if dependenciesMet:
                    # print('    Job {} meets dependencies for {}'.format(self.name, trigger['name']))
                    pass

                actionsDict = self.__dictionaryFromActions(otherActions, trigger)
                # print(str(actionsDict))

                triggerExpired = trigger['valid_until'] < time.time()
                if triggerExpired:
                    # print('Trigger is expired; skipping')
                    pass

                if dependenciesMet and not triggerExpired and self.wantToRun(actionsDict):
                    self.__actionId = self.__createStartedAction(pentest, trigger)
                    
                    # print('      Job started')
                    try:
                        result = self.run(actionsDict)
                    except Exception as ex:
                        err = "Exception: {}: {}".format(type(ex).__name__ , str(ex))
                        print("Unexpected error in job:", err)
                        self.__updateFinishedAction(self.__actionId, {'status': 'died', 'error': err, 'result': {}})
                        raise

                    # print('      Job finished')
                    self.__updateFinishedAction(self.__actionId, result)
                    # print('      Mongo updated')
                

    def wantToRun(self, actionResults):
        """ Override it (optional). Return true if there is anything to be done by the job given dependent actions' results."""
        """ If false is returned, the job will not be run despite meeting dependencies. """
        """ True by default"""
        return True

    def run(self, actions):
        """ Override this function. Actions parameter contains a dictionary of dependent action names with their results. """
        """ You are guaranteed to be given one successful result for each dependent action name as an input """
        """ actions['_trigger'] contains the root 'trigger' action. """
        """ """
        """ Return a dictionary: {'status': '[done|fail|anything]', 'result': <your custom payload here>} """
        """ Job will be retried until 'done' status is returned unless identical job in status 'started' is present (an in progress or crashed job). (TODO: limit number of reruns) """
        return {'status': 'not implemented', 'result': None}

    def ignorePreviousRuns(self):
        """ For debugging/development purposes only. Override it. If true is returned, the previous runs of this job (in both 'done' and 'started' status) will be ignored and the job will be executed regardless. Which result of the successful jobs is taken by other jobs is undefined."""
        if (len(sys.argv)>1 and sys.argv[1] == "--debug"):
            return True
        return False

