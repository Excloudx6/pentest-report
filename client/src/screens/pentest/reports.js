module.exports = {
    register: function({app, ensureLoggedIn, mongourl}) {

        app.post('/generate/archer', ensureLoggedIn(), function(req, res) {
            var Promise = require('bluebird');
            var XlsxTemplate = require('xlsx-template');
            var excel = require('node-excel-export');
            var mongoClient = Promise.promisifyAll(require('mongodb')).MongoClient;
            var pid = req.body.pid;
            var findings = null;
            var fs = require('fs');
            var path = require('path');

            mongoClient.connectAsync(mongourl)
                .then(function(db) {
                    return db.collection('findings').find({
                        "pentest_id": pid,
                        '_deleted': {
                            $ne: true
                        }
                    });
                    db.close();
                })
                .then(function(cursor) {
                    return cursor.toArrayAsync();
                })
                .then(function(content) {
                    findings = content || "";
                    findings = findings.filter(function(finding) { return finding.findingType !== 'FYI'; });
                    var order = ["Critical (GIA-Major)", "High", "Medium", "Low", "Info"];
                    findings.sort((a, b) => {
                        var firstOrder = order.indexOf(a.score);
                        var secondOrder = order.indexOf(b.score);
                        return firstOrder - secondOrder;
                    });
                    var nonMajor = {
                        priority: "Non-Major",
                        finimpact: "Non-Major"
                    };
                    var major = {
                        priority: "Major",
                        finimpact: "< $5MM USD"
                    };
                    for (var finding in findings) {
                        var theme_split = findings[finding].rt_ctrl.split(':');
                        findings[finding].rtheme = theme_split[0];
                        findings[finding].control = theme_split[1];

                        if (findings[finding]["score"] !== undefined) {
                            if (findings[finding]["score"].indexOf("GIA-Major") > -1) {
                                findings[finding]["priority"] = "Major";
                                findings[finding]["finimpact"] = "< $5MM USD";
                            } else {
                                findings[finding]["priority"] = "Non-Major";
                                findings[finding]["finimpact"] = "Non-Major";
                            }
                        } else {
                            findings[finding]["priority"] = "Undefined";
                            findings[finding]["finimpact"] = "Undefined";
                        }
                    }

                    complete();
                })
                .catch(function(err) {
                    throw err;
                });

            function complete() {
                if (findings !== null) {

                    // Load an XLSX file into memory
                    fs.readFile(path.join(__dirname, 'Archer_Template.xlsx'), function(err, data) {

                        // Create a template
                        var template = new XlsxTemplate(data);

                        // Replacements take place on first sheet
                        var sheetNumber = 1;

                        // Set up some placeholder values matching the placeholders in the template
                        var values = {
                            findings: findings
                        };

                        // Perform substitution
                        template.substitute(sheetNumber, values);

                        // Get binary data
                        var buf = template.generate({
                            type: 'nodebuffer'
                        });

                        // ...

                        var fileName = 'Archer_' + pid.replace(/ /g, "_") + '.xlsx';

                        // buf is a nodejs buffer, you can either write it to a file or do anything else with it.
                        fs.writeFileSync(path.resolve(__dirname, 'output.xlsx'), buf);

                        res.set('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
                        res.set('Content-disposition', 'attachment; filename=' + fileName);
                        res.set('Transfer-Encoding', 'chunked');
                        var outFile = fs.readFileSync(path.resolve(__dirname, 'output.xlsx'));
                        res.send(new Buffer(outFile.toString('base64')));
                    });
                }
            }
        });

        // todo: add ensureLoggedIn() to /generate once local user disabled. Does not work with local user
        app.post('/generate/report', ensureLoggedIn(), function(req, res) {

            var Promise = require('bluebird');
            var mongoClient = Promise.promisifyAll(require('mongodb')).MongoClient;
            var pid = req.body.pid;
            var properties = null;
	    var reporting = null;
            var findings = null;
            var snapshot = null;
            var appFindings = null;
            var infFindings = null;
            var proFindings = null;
            var fyiFindings = null;
            var t_entries = null;
            var dbConn = null;
            var defCount = 0;
            var definitions = [];
            var _ = require('underscore');

            mongoClient.connectAsync(mongourl)
                .then(function(db) {
                    return db.collection('pentests').find({
                        "_id": pid
                    })
                    db.close();
                })
                .then(function(cursor) {
                    return cursor.toArrayAsync();
                })
                .then(function(content) {
                    properties = content || "";
                    complete();
                })
                .catch(function(err) {
                    throw err;
                });


            mongoClient.connectAsync(mongourl)
                .then(function(db) {
                    return db.collection('reporting').find({
                        "pentest_id": pid
                    })
                    db.close();
                })
                .then(function(cursor) {
                    return cursor.toArrayAsync();
                })
                .then(function(content) {
                    reporting = content || "";
                    complete();
                })
                .catch(function(err) {
                    throw err;
                });


            mongoClient.connectAsync(mongourl)
                .then(function(db) {
                    return db.collection('timeline').find({
                        'pentest_id': pid,
                        '_deleted': {
                            $ne: true
                        }
                    }).sort({
                        tl_date: 1
                    });
                    db.close();
                })
                .then(function(cursor) {
                    return cursor.toArrayAsync();
                })
                .then(function(content) {
                    t_entries = content || "";
                    var dateFormat = require('dateformat');
                    for (var entry in t_entries) {
                        var oDate = new Date(t_entries[entry]["tl_date"]);
                        oDate = oDate.setHours(oDate.getHours() + 5);
                        var nDate = dateFormat(oDate, "ddd mm/dd/yy h:MM TT");
                        t_entries[entry]["tl_date"] = nDate;
                    }
                    complete();
                })
                .catch(function(err) {
                    throw err;
                });

            mongoClient.connectAsync(mongourl)
                .then(function(db) {
                    return db.collection('findings').find({
                        "pentest_id": pid,
                        '_deleted': {
                            $ne: true
                        }
                    });
                    db.close();
                })
                .then(function(cursor) {
                    return cursor.toArrayAsync();
                })
                .then(function(content) {
		    findings = content || "";
                    var order = ["Critical (GIA-Major)", "High", "Medium", "Low"];
                    findings.sort((a, b) => {
                        var firstOrder = order.indexOf(a.score);
                        var secondOrder = order.indexOf(b.score);
                        return firstOrder - secondOrder;
                    });

		    snapshot = JSON.parse(JSON.stringify(findings));;
            snapshot = snapshot.filter(function(snap) { return snap.findingType !== 'FYI'; });

            for (var finding in findings) {
                        if (findings[finding]["description"] !== undefined) {
                            findings[finding]["description"] = replaceNewLines(findings[finding]["description"], 11);
			}
                        if (findings[finding]["remediation"] !== undefined) {
                            findings[finding]["remediation"] = replaceNewLines(findings[finding]["remediation"], 11);          			     }
                    }

		    for (var snap in snapshot) {
                        if (snapshot[snap]["description"] !== undefined) {
                            snapshot[snap]["description"] = replaceNewLines(snapshot[snap]["description"], 9);
			}
                        if (snapshot[snap]["remediation"] !== undefined) {
                            snapshot[snap]["remediation"] = replaceNewLines(snapshot[snap]["remediation"], 9);
			}
		    }

                    appFindings = _.where(findings, {
                        findingType: 'Application'
                    });
                    infFindings = _.where(findings, {
                        findingType: 'Infrastructure'
                    });
                    proFindings = _.where(findings, {
                        findingType: 'Process'
                    });
                    fyiFindings = _.where(findings, {
                        findingType: 'FYI'
                    });
                    complete();
                })
                .catch(function(err) {
                    throw err;
                });

            mongoClient.connectAsync(mongourl)
                .then(function(db) {
                    dbConn = db;
                    defCount = db.collection('definitions').count();
                    Promise.resolve(defCount).then(function(value) {
                        defCount = value
                    }, function(value) {});
                    return db.collection('definitions').findAsync({});
                })
                .then(function(cursor) {
                    var count = -1;
                    var promises = [];
                    var a;
                    var b;

                    return new Promise((resolve, reject) => {

                        cursor.each(function(err, doc) {
                            if (doc !== null) {

                                promises.push(new Promise((res, rej) => dbConn.collection('pentests').findAsync({
                                        _id: pid,
                                        $text: {
                                            $search: "\"" + doc.Word + "\""
                                        }
                                    })
                                    .then(function(pWords) {
                                        return pWords.toArrayAsync();
                                    })
                                    .then(function(pwMatch) {
                                        if (pwMatch.length > 0) {
                                            definitions.push(doc);
                                        }
                                        res("resolved");
                                    })
                                    .catch(err => console.log('Catch', err))));

                                promises.push(new Promise((res, rej) => dbConn.collection('pentests').findAsync({
                                        _id: pid,
                                        $text: {
                                            $search: "\"" + doc.Abbreviation + "\""
                                        }
                                    })
                                    .then(function(pAbbr) {
                                        return pAbbr.toArrayAsync();
                                    })
                                    .then(function(paMatch) {
                                        if (paMatch.length > 0) {
                                            definitions.push(doc);
                                        }
                                        res("resolved");
                                    })
                                    .catch(err => console.log('Catch, err'))));

                                promises.push(new Promise((res, rej) => dbConn.collection('findings').findAsync({
                                        pentest_id: pid,
                                        $text: {
                                            $search: "\"" + doc.Word + "\""
                                        }
                                    })
                                    .then(function(fWords) {
                                        return fWords.toArrayAsync();
                                    })
                                    .then(function(fwMatch) {
                                        if (fwMatch.length > 0) {
                                            definitions.push(doc);
                                        }
                                        res("resolved");
                                    })
                                    .catch(err => console.log('Catch, err'))));

                                promises.push(new Promise((res, rej) => dbConn.collection('findings').findAsync({
                                        pentest_id: pid,
                                        $text: {
                                            $search: "\"" + doc.Abbreviation + "\""
                                        }
                                    })
                                    .then(function(fAbbr) {
                                        return fAbbr.toArrayAsync();
                                    })
                                    .then(function(faMatch) {
                                        if (faMatch.length > 0) {
                                            definitions.push(doc);
                                        }
                                        res("resolved");
                                    })
                                    .catch(err => console.log('Catch, err'))));

                                promises.push(new Promise((res, rej) => dbConn.collection('timeline').findAsync({
                                        pentest_id: pid,
                                        $text: {
                                            $search: "\"" + doc.Word + "\""
                                        }
                                    })
                                    .then(function(tWords) {
                                        return tWords.toArrayAsync();
                                    })
                                    .then(function(twMatch) {
                                        if (twMatch.length > 0) {
                                            definitions.push(doc);
                                        }
                                        res("resolved");
                                    })
                                    .catch(err => console.log('Catch, err'))));

                                promises.push(new Promise((res, rej) => dbConn.collection('timeline').findAsync({
                                        pentest_id: pid,
                                        $text: {
                                            $search: "\"" + doc.Abbreviation + "\""
                                        }
                                    })
                                    .then(function(tAbbr) {
                                        return tAbbr.toArrayAsync();
                                    })
                                    .then(function(taMatch) {
                                        if (taMatch.length > 0) {
                                            definitions.push(doc);
                                        }
                                        res("resolved");
                                    })
                                    .catch(err => console.log('Catch, err'))));
                            }
                            count++;
                            if (count === defCount) {
                                Promise.all(promises).then(function(values) {
                                    resolve(definitions);
                                });
                            }
                        })
                    })
                })
                .then(function(content) {
                    definitions = (definitions.length === 0 ? ["filler"] : content);
                    dbConn.close();
                    complete();
                })
                .catch(function(err) {
                    throw err;
                });

            //b64 image conversion docxtemplater
            function base64DataURLToArrayBuffer(dataURL) {
                Canvas = require('canvas');
                let im = new Canvas.Image;
                im.onload = function() {
                    imgHeight = im.height;
                    imgWidth = im.width;
                };
                im.src = dataURL;
                const base64Regex = /^data:image\/(png|jpg);base64,/;
                if (!base64Regex.test(dataURL)) {
                    return false;
                }
                const stringBase64 = dataURL.replace(base64Regex, "");
                let binaryString;
                if (typeof window !== "undefined") {
                    binaryString = window.atob(stringBase64);
                } else {
                    binaryString = new Buffer(stringBase64, "base64").toString("binary");
                }
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    const ascii = binaryString.charCodeAt(i);
                    bytes[i] = ascii;
                }

                return bytes.buffer;
            }

            function getDimensions(dataURL) {
                Canvas = require('canvas');
                let im = new Canvas.Image;
                im.onload = function() {
                    imgHeight = im.height;
                    imgWidth = im.width;
                };
                im.src = dataURL;

                if (imgWidth > 700) {
                    var imgDiff = imgWidth - 700;
                    var scaling = (imgWidth - imgDiff )/ imgWidth;
                    imgWidth = Math.floor(scaling*imgWidth);
                    imgHeight = Math.floor(scaling * imgHeight);
                }
                return [imgWidth, imgHeight];
            }

            function replaceNewLines(paragraphData, fontSize) {
		paragraphData = paragraphData.replace(/&/g, '&amp;')
		    .replace(/</g, '&lt;')
		    .replace(/>/g, '&gt;')
		    .replace(/"/g, '&quot;')
		    .replace(/'/g, '&apos;');
		var size = fontSize*2;
		var lines = paragraphData.split("\n");
		var pre = "<w:p><w:r><w:rPr><w:rFonts w:ascii='Calibri (Body)' w:cs='Times New Roman'/><w:sz w:val='" + size + "'/></w:rPr><w:t>";
                var post = "</w:t></w:r></w:p>";
                var lineBreak = "<w:br/>";
                return pre + lines.join(lineBreak) + post;
            }

            function complete() {
                if (properties !== null && findings !== null && t_entries !== null && reporting !== null && definitions.length > 0) {
		    var uDefs = _.uniq(definitions, '_id');

                    //docxtemplater
                    var ImageModule = require('docxtemplater-image-module');
                    var JSZip = require('jszip');
                    var Docxtemplater = require('docxtemplater');

                    var fs = require('fs');
                    var path = require('path');

                    var opts = {};
                    opts = {
                        centered: true
                    }
                    opts.getImage = function(tagValue) {
                        return base64DataURLToArrayBuffer(tagValue);
                    }
                    opts.getSize = function(img, tagValue) {
                        var dimensions = getDimensions(tagValue);
                        return [dimensions[0], dimensions[1]];
                    }

                    var imageModule = new ImageModule(opts);

                    //Replace items that could contain new lines with raw XML
                    if (properties[0]["description"] !== undefined) {
                        properties[0]["description"] = replaceNewLines(properties[0]["description"], 11);
                    }
                    for (var entry in t_entries) {
                        if (t_entries[entry]["tl_description"] !== undefined) {
                            t_entries[entry]['tl_description'] = replaceNewLines(t_entries[entry]['tl_description'], 9);
                        }
                    }
                    if (reporting.length > 0) {
                        reporting[0]["exec_summary"] = replaceNewLines(reporting[0]["exec_summary"], 11);
                    } else {
                        reporting = {};
                        reporting[0] = [];
                        var data = { exec_summary: "" };
                        reporting[0].push(data);
                    }

                    //Load the docx file as a binary
                    var content = fs
                        .readFileSync(path.resolve(__dirname, 'PenTestTemplate.docx'), 'binary');

                    var zip = new JSZip(content);

                    var doc = new Docxtemplater();
                    doc.attachModule(imageModule);
                    doc.loadZip(zip);
                    //set the templateVariables
                    doc.setData({
                        properties: properties,
                        findings: findings,
                        appFindings: appFindings,
                        infFindings: infFindings,
                        proFindings: proFindings,
                        fyiFindings: fyiFindings,
                        snapshot: snapshot,
                        tl_entries: t_entries,
                        pentest_name: properties[0]['name'],
                        pentest_leader: properties[0]['projectLeader'],
                        executive_summary: reporting[0]['exec_summary'],
                        team_members: properties[0]['teamMembers'],
                        activities: properties[0]['activities'],
                        hosts: properties[0]['hosts'],
                        definitions: uDefs
                    });

                    try {
                        // render the document (replace all occurences of {first_name} by John, {last_name} by Doe, ...)
                        doc.render()
                    } catch (error) {
                        var e = {
                            message: error.message,
                            name: error.name,
                            stack: error.stack,
                            properties: error.properties,
                        }
                        console.log(JSON.stringify({
                            error: e
                        }));
                        // The error thrown here contains additional information when logged with JSON.stringify (it contains a property object).
                        throw error;
                    }
                    var fileName = 'RedTeamPenTestReport_' + pid.replace(/ /g, "_") + '.docx';

                    var buf = doc.getZip()
                        .generate({
                            type: 'nodebuffer'
                        });

                    // buf is a nodejs buffer, you can either write it to a file or do anything else with it.
                    fs.writeFileSync(path.resolve(__dirname, 'output.docx'), buf);

                    res.set('Content-Type', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document');
                    res.set('Content-disposition', 'attachment; filename=' + fileName);
                    res.set('Transfer-Encoding', 'chunked');
                    var outFile = fs.readFileSync(path.resolve(__dirname, 'output.docx'));

                    res.send(new Buffer(outFile.toString('base64')));

                }
            }
        });



    }
};
