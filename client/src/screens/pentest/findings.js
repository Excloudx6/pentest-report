import './findings.css';

import React, { Component } from 'react';
import {Message, Confirm,Icon, Form, List, Grid, Button, Segment, Label, Responsive} from 'semantic-ui-react';
import 'whatwg-fetch';
import {randomID, urlPrefix, setCurrentTime} from '../../utils.js';
import update from 'immutability-helper';
import Attachments from "./Attachments.js";
import ConfigurableForm from "./ConfigurableForm.js";
import FindingPicker from "./FindingPicker.js";
import RawDataModal from '../RawDataModal.js'

// Note: name, description and remediation are hardcoded for performance reasons. The lag of full state update AND dynamic fields was too big otherwise.
const config = {
  inputs: [
    {
      label: 'Type',
      name: 'findingType',
      type: 'radio',
      options: ['Application','Infrastructure','Process','Chain']
    },
    {
      label: 'Effort',
      name: 'effort',
      type: 'radio',
      options:  ['Low','Medium','High','Critical']
    },
    {
      label: 'Impact',
      name: 'impact',
      type: 'radio',
      options:  ['Low','Medium','High','Critical']
    },
    {
      label: 'Score',
      name: 'score',
      type: 'radio',
      options:  ['Info','Low','Medium','High','Critical (GIA-Major)']
    },
    {
      label: 'Date Exploited',
      name: "dateExploited",
      type: 'datetime',
    },
    {
      label: 'Hosts',
      name: 'hosts',
      type: 'multipleChoice',
      options:
        [
        ]
    }
  ]
};

export class PentestFinding extends Component {
  state = {
    //properties: {},
    dirty: false,
    showDeleted: false,
    showDeleteConfirmation: false,
  }

  componentDidMount() {
    // this.loadState();
  }

  readOnly = () => {
    return this.props.lastEditBySomeoneElse && this.props.lastEditBySomeoneElse.danger
  };

  handleInputChange = (event, data) => {

      if(this.readOnly()) {
        console.log('SKIPPING EDIT: the finding is read only!')
        return;
      }

      const target = event.target;
      const value = target.type === 'checkbox' ? target.checked : data.value;
      const name = data.name;

      //let newProperties =  JSON.parse(JSON.stringify(this.state.properties));
      // console.log(event.target);
      // console.log(data);
      this.props.onChange(this.props.finding.id, name, value);
//      newProperties[name]=value;
          //update(this.state.properties, {[name]: {$set: value}});
  //    this.setState({properties: newProperties, dirty:true});
  }

  handleDelete = () => { this.setState({showDeleteConfirmation: true}); }
  handleDeleteCancel = () => { this.setState({showDeleteConfirmation: false}); }
  handleDeleteConfirm = () => {
    this.setState({showDeleteConfirmation: false});
    this.props.onDelete(this.props.finding.id);
  }

  handleUndelete = () => {
    this.props.onUndelete(this.props.finding.id);
  }

  handleAttachmentUpload = (filename, data, attachmentId) => {
    if(this.readOnly()) {
      console.log('SKIPPING EDIT: the finding is read only!')
      return;
    }

    this.props.onAttachmentUpload(this.props.finding.id, filename, data, attachmentId);
  }

  handleAttachmentDelete = (attachmentId) => {
    if(this.readOnly()) {
      console.log('SKIPPING EDIT: the finding is read only!')
      return;
    }

    this.props.onAttachmentDelete(this.props.finding.id, attachmentId);
  }

  handleAttachmentLabelChange = (attachmentId, label) => {
    if(this.readOnly()) {
      console.log('SKIPPING EDIT: the finding is read only!')
      return;
    }

    this.props.onAttachmentLabelChange(this.props.finding.id, attachmentId, label);
  }

  render() {
    if(!this.props.finding) return <div></div>;
    return (
      <div>
      
      {(this.props.lastEditBySomeoneElse && this.props.lastEditBySomeoneElse.danger) && <Message error>EDIT LOCKED. This finding is being actively edited by <b>{this.props.lastEditBySomeoneElse.username}</b>. Your edits would overwrite changes of others.</Message>}
      {(this.props.lastEditBySomeoneElse && this.props.lastEditBySomeoneElse.warning && !this.props.lastEditBySomeoneElse.danger) && <Message warning>Be careful! This finding was recently edited by <b>{this.props.lastEditBySomeoneElse.username}</b>.</Message>}
      <Grid>
      <Grid.Row>
      <Grid.Column width="12">
        <h3>{this.props.finding.name} <RawDataModal json={this.props.finding}/></h3>
      </Grid.Column>
      <Grid.Column width="4" textAlign="right">
      {!this.props.finding._deleted && (
        <span>
        <Button onClick={this.handleDelete} negative basic={true} content="Delete" />
        <Confirm
          open={this.state.showDeleteConfirmation}
          onConfirm={this.handleDeleteConfirm}
          onCancel={this.handleDeleteCancel}
          confirmButton='Delete'
          size='tiny'
        />
        </span>
      )}
      {this.props.finding._deleted && <Button onClick={this.handleUndelete} basic={true} content="Undelete" />}
      </Grid.Column>
      </Grid.Row>
      </Grid>

      <Form>
      <Form.Input name='name' label='Name' value={this.props.finding.name || ""}  onChange={this.handleInputChange} width={16}/>
      <Form.TextArea rows='25' autoHeight name='description' label='Description' value={this.props.finding.description || ""} onChange={this.handleInputChange}/>
      <Form.TextArea rows='6' autoHeight name='remediation' label='Remediation' value={this.props.finding.remediation || ""} onChange={this.handleInputChange}/>
      {this.props.retest && (<span>
      <Message>
      <Message.Header>Retest Properties</Message.Header>
      <br/>
      <Form.TextArea autoHeight name='retestNotes' label='Notes' value={this.props.finding.retestNotes || ""} onChange={this.handleInputChange}/>
      <Form.Group inline key="retestStatus">
        <label style={{"width": "70px"}}>Status</label>
        {['Remediated', 'Not Remediated', 'Not Tested'].map((value) => <Form.Radio key={'retestStatus' + value} name='retestStatus' label={value} value={value} checked={this.props.finding.retestStatus === value} onChange={this.handleInputChange} />)}
      </Form.Group>
      </Message>
      </span>)}
      </Form>
      <br/>
      <ConfigurableForm onChange={this.handleInputChange} values={this.props.finding} config={this.props.config}/>

      <Attachments pentestId={this.props.pentestId} attachments={this.props.finding.attachments} onUpload={this.handleAttachmentUpload} onDelete={this.handleAttachmentDelete} onLabelChange={this.handleAttachmentLabelChange}/>

      </div>
  )}
}


const ListItemWrapper = (props) =>
  <List.Item {...props} style={props.selected ? {"backgroundColor": "#ddd"} : {}} onClick={(e) => props.onClick(e, props)}/>;





/////////////////////////////////////////////////////////////////////////////////////////////

// finding.id are keys to the object, set if a findings's save is in progress. 
// Moved outside of the state to use it as a semaphore. Any better ideas how to solve it? 
var saveInProgress = {};
var loadInProgress = false;
var interval = null;

export class PentestFindings extends Component {
    state = {
      selectedFindingId: null,
      findings: [],
      dirty: {},    
      config: config,
      lastEditBySomeoneElseMap: {}
    }

    

    componentDidMount() {
        this.loadFindings();
        this.loadHosts();

        let refreshIntervalSeconds = 30;
        interval = setInterval(this.handleScheduledSave, 1000*refreshIntervalSeconds);
        //
        // console.log("update:");
        // console.log(update);
        // console.log(require('immutability-helper').update);
        // const myData = {x:{y:{z:0}}};
        // const newData = update(myData, {});
    }

    componentWillUnmount() {
      // try to save data...
      this.handleSave();
      clearInterval(interval);
    }

    handleScheduledSave = () => {
      console.log('Regular SAVE');

      this.handleSave();
      this.loadFindings();

      // TODO: synchronize handleSave events and schedule next save X seconds after the previous save is FINISHED.
      // setTimeout(this.handleScheduledSave, 1000);
    }

    handleClone = ({finding_id, pentest_id}) => {
      if(!finding_id)
        return;
      // alert("NOT IMPLEMENTED YET");
      console.log("CLONGING:"+ finding_id);

      let t = this;
      fetch(urlPrefix + '/api/v1/findings/?_deleted!=true&pentest_id='+pentest_id+'&id='+finding_id, {method: 'get',credentials: 'include'})
      .then(response => {
          return response.json()})
      .then(function(json) {
          if('success' in json && json.success === false) {
            console.log("ERROR: " + JSON.stringify(json, null, 4));
            t.setState({error: json});
            return;
          }

          console.log("got finding to clone: " +JSON.stringify(json,null,4));
          let original = json[0];

          let newdocument = {
              pentest_id: t.props.match.params.code,
              id: randomID(),
              dateExploited: setCurrentTime('full'),
              attachments: [],
              name: original.name,
              description: original.description,
              remediation: original.remediation,
              context: original.context,
              findingType: original.findingType,
              effort: original.effort,
              impact: original.impact,
              score: original.score,
              owasp: original.owasp,
              bus_imp: original.bus_imp,
              rt_ctrl: original.rt_ctrl,
              ciValueAdd: original.ciValueAdd
          };
          t.setDirty(newdocument.id);
          t.setState({
            findings: update(t.state.findings, {$push: [newdocument]}),
            selectedFindingId: newdocument.id
          });

      }).catch(function(ex) {
          console.log("ERROR:" + ex);
      });

    }


    handleCreate = ( e, { action }) => {
            // let t=this;
            let newdocument = {
                pentest_id: this.props.match.params.code,
                id: randomID(),
                dateExploited: setCurrentTime('full'),
                attachments: []
            };
            this.setDirty(newdocument.id);
            this.setState({
              findings: update(this.state.findings, {$push: [newdocument]}),
              selectedFindingId: newdocument.id
            });
            // let headers = {
            //     'Content-Type': 'application/json'
            // };
            //
            // fetch(urlPrefix + '/api/v1/findings/'+randomID(),
            //   {method: 'put',credentials: 'include', body: JSON.stringify(newdocument), headers:headers})
            // .then(response => {
            //     return response.json()})
            // .then(function(json) {
            //     if ('error' in json) {
            //         t.setState({error: json});
            //     } else {
            //         console.log("Document created: " +JSON.stringify(json,null,4));
            //         t.loadFindings();
            //     }
            // }).catch(function(ex) {
            //     console.log("ERROR:" + ex);
            // });
    }

    // Merges findings from the server with findings already loaded and potentially modified. 
    // At minimum, we need to detect colliding edits here and not overwrite ongoing modifications that
    // were not yet saved.
    
    mergeFindings(remoteFindings) {
      // console.log("Merging findngs");
      // console.log(remoteFindings);

      let t=this;
      remoteFindings.map((remoteFinding)=>{
        this.setState((state)=>{
          let remoteFindingAlreadyExists=false;
          let updatedFindings = state.findings.map(localFinding=>{
            if(localFinding.id!==remoteFinding.id)
              return localFinding;

            remoteFindingAlreadyExists=true;
            if(t.isDirty(localFinding.id)) {
              console.log('SKIPPING finding from the server, local finding is DIRTY.');
              return localFinding;
            } else {
              if(remoteFinding.updateTimestamp > localFinding.updateTimestamp || localFinding.updateTimestamp===undefined)
                return remoteFinding;
              else {
                console.log('LOCAL FINDING is newer than the remote one. SKIPPIN the REMOTE one');
                return localFinding;
              }
            }
          });

          if(!remoteFindingAlreadyExists) {
            updatedFindings = update(updatedFindings, {$push: [remoteFinding]});
          }
          
          return {findings: updatedFindings};
        }, ()=> {
          // caching last updated by someone else results.
          t.setState((state)=>{
            let lastEditBySomeoneElseMap={};
            this.state.findings.forEach(finding=>lastEditBySomeoneElseMap[finding.id]=t.lastEditBySomeoneElse(finding));
            return {lastEditBySomeoneElseMap: lastEditBySomeoneElseMap}});
        }

        );
      return 0;
      });

      this.setState({loaded: true});
    }

    loadFindings(showDeleted = false) {

      if(loadInProgress) {
        console.log('PARALLEL LOAD in progress. Skipping load findings.');
        return;
      }
      // console.log('LOAD START ---');
      loadInProgress=true;  

      let t = this;
      // TODO: ENCODE !!!!!!!!! (vulnerable?)
      let isDeletedFilter = showDeleted ? '' : "_deleted!=true&";
    
      fetch(urlPrefix + '/api/v1/findings/?'+ isDeletedFilter+'pentest_id='+this.props.match.params.code, {method: 'get',credentials: 'include'})
      .then(response => {
        loadInProgress=false;
        // console.log('LOAD END ---');
        return response.json()})
      .then(function(json) {
          if('success' in json && json.success === false) {
            console.log("ERROR: " + JSON.stringify(json, null, 4));
            t.setState({error: json});
            return;
          }

          console.log("got findigs: ");// +JSON.stringify(json,null,4));
          t.mergeFindings(json); 
          //t.setState({findings: json, loaded: true});
      }).catch(function(ex) {
        loadInProgress=false;
        console.log("ERROR:" + ex);
      });
    }

    loadHosts = () => {
        let t = this;
        // TODO: ENCODE !!!!!!!!! (vulnerable?)
        fetch(urlPrefix + '/api/v1/pentests/'+this.props.match.params.code, {method: 'get',credentials: 'include'})
        .then(response => {
            return response.json()})
        .then(function(json) {
            if('success' in json && json.success === false) {
              console.log("ERROR: " + JSON.stringify(json, null, 4));
              t.setState({error: json});
              return;
            }

            console.log("got hosts: " +JSON.stringify(json,null,4));

            var hosts = json.hosts;
            var retest = json.retest;
            var hostsOptions = hosts.map((host) => {
              var text = host.ip;
              if(host.hostname && host.hostname.length > 0) text = text + " ; " + host.hostname;
              if(host.comment && host.comment.length > 0) text = text + " ; " +host.comment + "";

              // warning: editing comment will unlink the finiding
              return {
                key: ''+host.ip+host.hostname,
                text: text,
                value: text
              }
            });

            var hostsConfigIndex = -1;
            console.log(t.state);
            t.state.config.inputs.forEach((el, index) => {if(el.name === 'hosts') hostsConfigIndex = index});
            console.log(hostsConfigIndex);
            t.setState({hosts: hosts, retest: retest, config: update(t.state.config, {inputs: {[hostsConfigIndex]: {options: {$set: hostsOptions}}}})});

        }).catch(function(ex) {
            console.log("ERROR:" + ex);
        });
    }


    setDirty = (id) => {
      // convention: existence of id entry in the array means dirty; Lack of element means clean.
      if(!(id in this.state.dirty))
        this.setState({dirty: update(this.state.dirty, {[id]: {$set: true} })});
    }

    clearDirty = (id) => {
        this.setState({dirty: update(this.state.dirty, {$unset: [id]})});
    }

    clearDirtyAll = () => {
      this.setState({dirty: {}});
    }

    isDirty = (id) => {
      return(id in this.state.dirty);
    }

    isAnythingDirty = () => {
      return Object.keys(this.state.dirty).length > 0;
    }


    handleSave = () => {
      var t = this;
      if(!this.props.whoami) 
        return; // not logged in

      if(this.state.findings) {
        
          this.state.findings.forEach(function(finding, index) {
              // Save only dirty findings to minimize overwrites of parallel changes done by others. This does not eliminate the risk though...
              // First, check if a finding is not being saved now. Avoid parallel saves of the same findings. saveInProgress global variable is used as a semaphore here.
              if(t.isDirty(finding.id) && saveInProgress[finding.id]) {console.log('Save in progress, will skip save');};
              if(t.isDirty(finding.id) && !saveInProgress[finding.id]) {
                let findingId = finding.id;

                // Update finding with save metadata
                t.setState((state, props)=>{

                  return (
                    {findings: 
                      state.findings.map((finding)=>{
                        if(finding.id !== findingId)
                          return finding;

                        console.log('------- Finding: '+findingId);                      
                        let now = Date.now();
                        let username = props.whoami.user.username;
                        let history = finding.updateHistory || [];
                        history = update(history, {$push: [{eventType: 'save', username: username, timestamp: now}]});

                        return update(finding, 
                          {$merge: {
                            updateTimestamp: now,
                            updateHistory: history,
                            updateUser: username
                          }}
                          );
                      })
                    });
                  }, 
                  ()=> {
                    // propagated the to-be-saved state. 
                    // Push finding to the server. 
                    let finding = t.state.findings.find(f=>f.id===findingId);
                    console.log('starting save of '+findingId);
                    saveInProgress[finding.id] = true;

                    fetch(urlPrefix + '/api/v1/findings/'+findingId,
                      {method: 'put',credentials: 'include', body: JSON.stringify(finding), headers: {
                         'Accept': 'application/json',
                         'Content-Type': 'application/json'
                    }})
                    .then(response => {
                        return response.json()})
                    .then(function(json) {
                        if('success' in json && json.success === false) {
                          console.log("ERROR: " + JSON.stringify(json, null, 4));
                          t.setState({error: json});
                          delete (t.saveInProgress)[findingId];
                          return;
                        }

                        console.log("saved findig: "+findingId);// +JSON.stringify(json,null,4));

                        var index = t.state.findings.findIndex((f) => (f.id === findingId));

                        // console.log('saved. LOCAL-LOCAL-REMOTE');
                        // console.log(finding);
                        // console.log(t.state.findings[index]);
                        // console.log(json);

                        // if state object for this finding is THE SAME one as as when the one when saving started.
                        if(t.state.findings[index]===finding) {
                          console.log('Clearing dirty flag')
                          // not clearing the dirty flag for findings that changed meanwhile...
                          // making use of immutabilty at last!
                          t.clearDirty(json.id);
                        } else {
                          console.log('Finding changed since save; Keeping it dirty.');
                        }
                        console.log("clearing saveInProgress for " + findingId);
                        console.log(saveInProgress);

                        delete (saveInProgress)[findingId];

                    }).catch(function(ex) {
                        console.log("ERROR:" + ex);
                        delete (saveInProgress)[findingId];
                    });


                  }
                );
                
                
              }
          });
        
      };
    }

    
    handleChange = (findingId, attribute, newValue) => {
      if(findingId !== this.state.selectedFindingId) {
        alert("Oppps: some race condition? HandleChange: " + findingId +" "+this.state.selectedFindingId);
        return;
      }
      this.setDirty(findingId);
      //
      // console.log(this.state);
      // console.log(this.getSelectedFindingArrayID());
      this.setState({findings:
        update(this.state.findings,
          {[this.getSelectedFindingArrayID()]: {[attribute]: {$set: newValue}}}
        )
      });

    }

    getSelectedFindingArrayID = () => {
      const findings = this.state.findings;
      return findings ? findings.findIndex((f) => (f.id === this.state.selectedFindingId)) : -1;
    }

    handleSelected = (e,{findingid}) => {
      console.log(e.target);
      console.log(findingid);
      this.setState({selectedFindingId: findingid});
      console.log(this.getSelectedFindingArrayID());
      console.log(this.state.findings[this.getSelectedFindingArrayID()]);
    }

    handleDelete = (id) => {
      this.handleChange(id, '_deleted', true);
      this.handleSave();
      this.setState({selectedFindingId: null});
    }

    handleUndelete = (id) => {
      this.handleChange(id, '_deleted', false);
      this.handleSave();
    }


    handleAttachmentDelete = (findingId, attachmentId) => {
      if(findingId !== this.state.selectedFindingId) {
        alert("Oppps: some race condition? HandleUpload: " + findingId +" "+this.state.selectedFindingId);
        return;
      }

      var findingArrayId = this.getSelectedFindingArrayID();
      var attachmentArrayId = this.state.findings[findingArrayId].attachments.findIndex((f) => (f.id === attachmentId));

      console.log('removing' + attachmentArrayId + ', ' + attachmentId);
      // remove attachment from array
      if (attachmentArrayId>=0) {
        this.setState({findings:
          update(this.state.findings,
            {[findingArrayId]: {attachments: {$splice: [[attachmentArrayId,1]]}}}
          )
        });
      }
    }

    handleAttachmentLabelChange= (findingId, attachmentId, label) => {
      if(findingId !== this.state.selectedFindingId) {
        alert("Oppps: some race condition? HandleUpload: " + findingId +" "+this.state.selectedFindingId);
        return;
      }

      var findingArrayId = this.getSelectedFindingArrayID();
      var attachmentArrayId = this.state.findings[findingArrayId].attachments.findIndex((f) => (f.id === attachmentId));

      // console.log('updating: ' + findingId + ',' + findingArrayId + ', ' + attachmentArrayId + ', ' + attachmentId);
      // remove attachment from array
      if (attachmentArrayId>=0) {
        this.setState({findings:
          update(this.state.findings,
            {[findingArrayId]: {attachments: {[attachmentArrayId]: {label: {$set: label}}}}}
          )
        });
      }

      this.setDirty(findingId);
    }


    handleAttachmentUpload = (findingId, filename, data, id) => {
      if(findingId !== this.state.selectedFindingId) {
        alert("Oppps: some race condition? HandleUpload: " + findingId +" "+this.state.selectedFindingId);
        return;
      }

      let attachment = {
        filename: filename,
        dataURL: data,
        id: id,
        label: ""
      };

      if (!('attachments' in this.state.findings[this.getSelectedFindingArrayID()]))
        this.setState({findings:
          update(this.state.findings,
            {[this.getSelectedFindingArrayID()]: {attachments: {$set: [attachment]}}}
          )
        });
      else
        this.setState({findings:
          update(this.state.findings,
            {[this.getSelectedFindingArrayID()]: {attachments: {$push: [attachment]}}}
          )
        });

      this.setDirty(findingId);
    }

    scoreToInt = (s) => {
      switch(s) {
        case "Critical (GIA-Major)": return 1;
        case "High": return 2;
        case "Medium": return 3;
        case "Low": return 4;
        case "Info": return 5;
        default: return 0;
      }
      // console.log('Finding order unknown: ' + s);
      // return 0;
    }

    findingCompare = (a,b) => {
      let ai = this.scoreToInt(a.score);
      let bi = this.scoreToInt(b.score);
      if(ai===bi) {
        // console.log('' + a.id + ' vs. ' + b.id + " -> " + ((a.id > b.id)?'TRUE':'false') );
        return (a.id > b.id ? 1 : -1);
      // } else {
        // console.log('' + ai + ' <-> ' + bi);
      }
      return ai > bi ? 1 : -1;
    }

    handleShowDeleted = () => {
      console.log("show deleted clicked");
      if(this.isAnythingDirty()) {
        alert("Save your chagnes before using this feature.");
        return;
      }
      this.setState({showDeleted: true, loaded: false, findings: []});
      this.loadFindings(true);

    }


    lastEditBySomeoneElse = (finding) => {
      if(!finding || !this.props.whoami || !finding.updateHistory)
        return {};

      let me = this.props.whoami.user.username;
      let now = Date.now();
      let lastEditBySomeoneElseDate = 0;
      let lastEditBySomeoneElseUsername="";
      finding.updateHistory.forEach(edit=>{
        if(edit.username !== me && edit.timestamp > lastEditBySomeoneElseDate) {
          lastEditBySomeoneElseDate = edit.timestamp;
          lastEditBySomeoneElseUsername = edit.username;
        } 
      });

      // danger - immediate danger of overwrite. Parallel edit not allowed.
      let dangerMinutesThreshold = 5;
      let danger = lastEditBySomeoneElseDate > now-1000*60*dangerMinutesThreshold;

      // Warning - edited by someone else recently, but not a disqualifier for edits.
      let warningMinutesThreshold = 30;
      let warning = lastEditBySomeoneElseDate > now-1000*60*warningMinutesThreshold;

      return {danger: danger, warning: warning, username: lastEditBySomeoneElseUsername, timestamp: lastEditBySomeoneElseDate};
    }


    render () {


      return (
        <div>
        {this.state.error && <Message error floating>{this.state.error.message}</Message>}
        <Grid>
          <Grid.Column width={6}>

                  <Grid columns='two'>
                      <Grid.Row>
                          <Grid.Column width={4}>
                              <h2>Findings</h2>
                              {!this.state.showDeleted && <div className="showDeleted"><a onClick={this.handleShowDeleted}>show deleted</a></div>}

                          </Grid.Column>
                          <Grid.Column width={12} textAlign="right">
                              <FindingPicker onSelect={this.handleClone} label="Clone" />
                              <Button onClick={this.handleCreate} content="Add" />
                              <Button primary={this.isAnythingDirty()} onClick={this.handleSave} basic={!this.isAnythingDirty()} content={this.isAnythingDirty() ? "Save All" : "Saved"} />


                          </Grid.Column>
                      </Grid.Row>
                  </Grid>

                  <List selection>
                  {'findings' in this.state && this.state.findings && this.state.findings.length>0 ?
                      this.state.findings.sort(this.findingCompare).map((row, index) => (
                        // warning: the above sort causes keyboard lag. How do I do it without resorting upon every keystroke??
                          (!row._deleted || this.state.showDeleted) &&
                          <ListItemWrapper selected={row.id===this.state.selectedFindingId} key={row.id} findingid={row.id} onClick={this.handleSelected}>
                          <List.Content >
                                <Grid columns='three'>
                                  
                                  <Grid.Row>
                                      <Grid.Column width="8">
                                          <List.Header >
                                              {row.name && row.name.length>0 ? <span>{row.name}</span> : <span className='noname'>no name</span>}
                                          </List.Header>
                                      </Grid.Column>


                                      <Grid.Column width="6" textAlign='right'>
                                          {row.score}
                                          {row.findingType && <Responsive className="findingTypeLabel" as={Label} minWidth={1200} horizontal color='grey'>{row.findingType.substring(0,3)}</Responsive>}
                                          {row._deleted && <Label color='red'>Deleted</Label>}
                                      </Grid.Column>

                                      <Grid.Column width="2" textAlign='center'>
                                          {this.isDirty(row.id) &&  <Icon color='blue' name='circle' />}
                                          {this.state.lastEditBySomeoneElseMap[row.id] && this.state.lastEditBySomeoneElseMap[row.id].danger &&  <Icon color='red' name='circle' />}
                                          {this.state.lastEditBySomeoneElseMap[row.id] && this.state.lastEditBySomeoneElseMap[row.id].warning && !this.state.lastEditBySomeoneElseMap[row.id].danger &&  <Icon color='orange' name='circle' />}
                                      </Grid.Column>

                                  </Grid.Row>
                                  
                              </Grid>

                          </List.Content></ListItemWrapper>
                      ))
                      :
                        (this.state.loaded?
                          <div>No findings yet.</div> :
                          <Segment basic loading={!('error' in this.state)}><div style={{'height': '150px'}}></div></Segment>
                        )
                  }
                  </List>



          </Grid.Column>
          <Grid.Column width={10}>
            <PentestFinding pentestId={this.props.match.params.code} retest={this.state.retest} finding={this.state.findings ? this.state.findings[this.getSelectedFindingArrayID()] : null} onUpdate={this.loadFindings} onChange={this.handleChange} onDelete={this.handleDelete} onUndelete={this.handleUndelete} onAttachmentUpload={this.handleAttachmentUpload} onAttachmentDelete={this.handleAttachmentDelete} onAttachmentLabelChange={this.handleAttachmentLabelChange} config={this.state.config} whoami={this.props.whoami} lastEditBySomeoneElse={this.state.findings && this.state.findings[this.getSelectedFindingArrayID()] ? this.state.lastEditBySomeoneElseMap[this.state.findings[this.getSelectedFindingArrayID()].id] : {}}/>
          </Grid.Column>
        </Grid>



        </div>
    )}
}
