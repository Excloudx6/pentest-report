#!/usr/bin/python3
from pymongo import MongoClient
#from pssh.pssh2_client import SSHClient
import paramiko
import time
import sys
import json
import os
import subprocess
import signal
import time
import argparse
from  termcolor import colored
from KnowledgeUtils import KnowledgeUtils

class SSHAll:
    def __init__(self, users=[], hosts=[]):
        """ Optionally, provide lists of hosts/users to *restrict* connections to. """
        self.utils = KnowledgeUtils()
        self.users_filter = users if users != None else []
        self.hosts_filter = hosts if hosts != None else []

        self.creds = self.getCreds()
        self.sessions = []

    def getCreds(self):
        creds = list(self.utils.knowledge.find({'type': 'state_action', 'subtype': 'result', 'pentest_id': self.utils.pentest_id, 'name': 'ssh_scanner'}))
        creds = [c['input'] for c in creds]
        # print(str(creds))
        creds = [c for c in creds if ((self.hosts_filter == [] or c['host'] in self.hosts_filter) and (self.users_filter == [] or c['username'] in self.users_filter))]
        return creds

    def connect(self):
        for c in self.creds:
            print('Connecting to: {}'.format(c['host']))

            ssh=paramiko.SSHClient()
            # tell the ssh client to automatically add any missing keys
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            ssh.connect(c['host'],username=c['username'],password=c['password'])
            self.sessions.append({'ssh':ssh, 'host': c['host'], 'username':c['username']})

    def shell(self):

        self.connect()
        print("\nConnected to {} hosts. Start typing commands. Ctrl-D when done.".format(len(self.sessions)))
        print("For bash-like history run via rlwrap: 'rlwrap cat | {} ...'".format(sys.argv[0]))
        print("No state. Each command is independent. 'cd /' will not move you anywhere. Sorry\n")

        for command in sys.stdin:
            command.strip()
            for s in self.sessions:
                try:
                    if s['ssh'].get_transport().is_active():

                        stdin, stdout, stderr = s['ssh'].exec_command(command, timeout=10.0)
                        stdoutstr = stdout.read().strip().decode()
                        stderrstr = stderr.read().strip().decode()
                        if(len(stdoutstr)>0):
                            print(colored("[{}, {}] STDOUT (exit_code: {}):".format(s['host'], s['username'], stdout.channel.recv_exit_status()), 'grey'))
                            print(stdoutstr)
                        if(len(stderrstr)>0):
                            print(colored("[{}, {}] STDERR (exit_code: {}):".format(s['host'], s['username'], stdout.channel.recv_exit_status()), 'grey'))
                            print(colored(stderrstr, 'red'))
                        print(colored("# ", 'grey'), end='', flush=True)
                    else:
                        print("{} died meanwhile".format(str(s)))

                except (Exception) as g:
                    print(g)
                    pass

        print("Disconnecting")
        for s in self.sessions:
            s['ssh'].close()

    def xterm(self, nopipe=False, font_size=8):
        print('Staring')
        cwd = os.getcwd()
        os.system('rm -rf {}/pipes'.format(cwd))
        os.system('mkdir {}/pipes'.format(cwd))
        # os.system('mkfifo {}/pipes/stdin_all'.format(cwd))
        pipes = []
        fpipes = []
        for c in self.creds:
            print('   Terminal for: {}'.format(c['host']))
            pipename = '{}/pipes/{}_{}_{}'.format(cwd, c['host'], c['port'], c['username'])
            pipes.append(pipename)
            os.system('mkfifo {}'.format(pipename))
            if(nopipe):
                subprocess.Popen("xterm -fa 'Monospace' -fs {} -geometry 100x40 -e 'sshpass -p {} ssh -o StrictHostKeyChecking=no  {}@{} -tt'  & ".format(font_size,c['password'],c['username'],c['host']), shell=True)
            else:
                subprocess.Popen("xterm -fa 'Monospace' -fs {} -geometry 100x40 -e 'sshpass -p {} ssh -o StrictHostKeyChecking=no  {}@{} -tt < {} ; echo DONE; read' & ".format(font_size, c['password'],c['username'],c['host'], pipename), shell=True)
                f = open(pipename, 'w')
                fpipes.append(f)

        time.sleep(1)
        ### SHELL INJECTION HERE AND ABOVE VIA malicious hostname in db !!! BEWARE!

        #pipesstr = ' '.join(pipes)
        #print('cat ./pipes/stdin_all | tee -a {} &'.format(pipesstr))
        #subprocess.Popen('cat ./pipes/stdin_all | tee -a {} &'.format(pipesstr), shell=True, stdout=subprocess.DEVNULL)

        if(nopipe):
            input("Press <enter> to kill all xterms.")
        else:
            print('\nConnected to all shells. Click here to refocus. Type commands here.')
            print('Run it with rlwrap to get bash-like history. E.g. rlwrap cat | {} ... \n'.format(sys.argv[0]))

            #os.system('rlwrap cat > ./pipes/stdin_all')

            for command in sys.stdin:
    #            for p in pipes:
    #                os.system('echo "{}" > {}'.format(command, p))
                for f in fpipes:
                    f.write(command)
                    f.flush()

#
# parser = argparse.ArgumentParser(description='Interactively executesssh commands against all known hosts / credentials.')
# parser.add_argument('-U', '--user', type=str, nargs='*', help='Connect only as a given username. Can provide many usernames (e.g. -U john tom alice)' )
# parser.add_argument('-H', '--host', type=str, nargs='*', help='Connect only to a given host. Can provide many (e.g. -H 1.2.3.4 1.2.33.44)' )
#
# group = parser.add_mutually_exclusive_group(required=True)
# group.add_argument('-x', '--xterm', action='store_true', help='one XTerm for each user/host. Fully interactive.')
# group.add_argument('-s', '--shell', action='store_true', help='inline shell. Not entirely interactive.')
# args = parser.parse_args()
# # print(args)
#
# s = SSHAll(users=args.user, hosts=args.host)
# if(args.shell):
#     s.shell()
# if(args.xterm):
#     s.xterm()

os.setpgrp() # create new process group, become its leader
try:


    parser = argparse.ArgumentParser(description='Interactively executesssh commands against all known hosts / credentials.')
    parser.add_argument('-U', '--user', type=str, nargs='*', help='Connect only as a given username. Can provide many usernames (e.g. -U john tom alice)' )
    parser.add_argument('-H', '--host', type=str, nargs='*', help='Connect only to a given host. Can provide many (e.g. -H 1.2.3.4 1.2.33.44)' )
    parser.add_argument('-i', '--independent', action='store_true', help='Independent input to each XTerm window (by default they all get input from the console window).' )
    parser.add_argument('-f', '--font-size', type=int, default=8, help='Font size' )

    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('-x', '--xterm', action='store_true', help='one XTerm for each user/host. Fully interactive.')
    group.add_argument('-s', '--shell', action='store_true', help='inline shell. Not entirely interactive.')
    args = parser.parse_args()
    print(args)

    s = SSHAll(users=args.user, hosts=args.host)
    if(args.shell):
        s.shell()
    if(args.xterm):
        s.xterm(nopipe=args.independent, font_size=args.font_size)

except OSError as e:
    print( e.errno)
    print(e.filename)
    print(e.strerror)
finally:
    print(str(sys.exc_info()[0]))
    # This is to kill all subprocesses
    os.killpg(0, signal.SIGKILL) # kill all processes in my group
