#!/usr/bin/python3
from StateAction import StateAction
import paramiko
import socket

class SSHScanner(StateAction):
    def __init__(self, userpass=[]):
        """ usrepass: list of ('username','password') tuples. If not provided, userpass will be taken from the knowledge 'known_userpass' records  """
        super().__init__('ssh_scanner', ['host', 'port', 'username', 'password'], ['host', 'port', 'username'])
        self.userpass=userpass

    def emit(self):

        hosts = list(self.utils.knowledge.find({'type': 'port', 'pentest_id': self.utils.pentest_id, 'data.name': 'ssh'}))

        if (len(self.userpass)==0):
            # Take userpass form the knowledge database
            known = self.utils.knowledge.find({'type': 'known_userpass', 'pentest_id': self.utils.pentest_id, 'purpose': 'ssh'})
            for k in known:
                for up in k['data']:
                    self.userpass.append( tuple([up[0], up[1]]) )


        product = []
        for h in hosts:
            for (u,p) in self.userpass:
                product.append({**(self.strip(h, ['host', 'port'])), **{'username':u, 'password':p}})

        product =  sorted(product, key= lambda creds: creds['username']);
        print(str(self.userpass))
        print('scanning {} combinations ({} hosts, {} userpasses)'.format(len(product), len(hosts), len((self.userpass))))

        return product;

    def work(self, params):

        target_ssh=paramiko.SSHClient()
        # tell the ssh client to automatically add any missing keys
        target_ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())

        try:
            # connect to the target box via ssh
            print("Connecting to {} as {}/{}".format(params['host'], params['username'], params['password']))
            target_ssh.connect(params['host'],username=params['username'],password=params['password'])
            target_sshtransport = target_ssh.get_transport()

            commands = ['id']
            stdoutstr, stderrstr = b"", b""
            #if no errors, execute commands on the target
            for command in commands:
                try:
                    if target_ssh.get_transport().is_active():
                        stdin, stdout, stderr = target_ssh.exec_command(command, timeout=10.0)
                        print("Executing `{}`".format( command ))

                        stdoutstr = stdout.read().strip()
                        stderrstr = stderr.read().strip()
                        print(stdoutstr)
                        exit_status = stdout.channel.recv_exit_status()

                except (Exception) as g:
                    print(g)
                    return {'status':2, 'stdout': stdoutstr.decode(), 'stderr': stderrstr.decode()}
                    pass

            # Close the target ssh session - this would be faster if you looped before closing
            target_ssh.close()

            return {'status':1 if(exit_status==0) else 0, 'stdout': stdoutstr.decode(), 'stderr': stderrstr.decode(), 'exit_status': exit_status}

        except (paramiko.BadHostKeyException, paramiko.AuthenticationException, paramiko.SSHException, socket.error) as e:
            print("Failed: {}".format(str(e)))
            return {'status':0, 'error': str(e)}
            pass

ssh = SSHScanner()
ssh.run(retry=False, retry_successful=False)
